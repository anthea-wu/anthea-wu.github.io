[{"content":"什麼是 Pre-commit Hook Git pre-commit hook 是一種本地腳本，在跑 git commit 命令時會自動執行。這些 hook 可以用來確保程式碼品質，例如 run test、TypeScript 型別檢查、執行 ES Lint 等等，確保只有合格的程式碼才能被提交。\nLocal Hook 的好處 只影響 local，不會干擾其他團隊成員 → 以我們團隊來說，因為每個人電腦規格不同，如果大家 commit 前都需要跑過一次測試可能會很沒有效率，所以我選擇只寫在自己的 local 上 不需要修改專案的 package.json 不會被提交到版本庫 可以根據個人需求自定義檢查內容 設置步驟 1. 建立 hooks 目錄 1 mkdir -p .git/hooks 2. 建立 pre-commit 檔案 1 touch .git/hooks/pre-commit 3. 編寫 pre-commit 腳本 將以下內容寫入 .git/hooks/pre-commit 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/sh echo \u0026#34;Running pre-commit hook: tests and type checking...\u0026#34; # Exit on error set -e # Run tests echo \u0026#34;Running tests...\u0026#34; npm run test # Run type checking echo \u0026#34;Running type checking...\u0026#34; npm run tsc echo \u0026#34;All checks passed! Proceeding with commit.\u0026#34; 4. 設定執行權限 1 chmod +x .git/hooks/pre-commit 測試與使用 建立一個測試 commit：\n1 2 git add . git commit -m \u0026#34;Test commit\u0026#34; 如果設置正確，執行後就會看到測試與 TypeScript 型別檢查完後才會真的 commit 成功。\n如果需要臨時跳過 hook 檢查：\n1 git commit --no-verify Q\u0026amp;A 如果我設定了這個 pre-commit 的內容，是不是連後端專案的 commit 都會跑過這個 pre-commit？\npre-commit hook 是儲存在每個 Git 儲存庫的 .git/hooks 目錄中，只對該特定儲存庫有效。\n所以說，我們在哪個專案中設定的 pre-commit hook：\n只會在對這個專案進行 commit 時執行 不會影響電腦上的其他專案（如後端專案） 每個 Git 儲存庫都有自己獨立的 hooks 設定 ","date":"2025-03-16T10:00:00+08:00","permalink":"https://anthea-wu.github.io/post/git-pre-commit-hook-local-setup/","title":"如何在 local 設置 Git Pre-commit Hook"},{"content":"前言 剛接觸 JavaScript 的時候不知道大家有沒有看過這個情境：\n1 2 3 4 5 6 7 console.log(\u0026#34;A\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;B\u0026#34;); }, 0); console.log(\u0026#34;C\u0026#34;); 你覺得跑完上面的程式碼後，最後 log 印出來的順序是什麼呢？\n如果你的答案是 A → B → C 的話，歡迎你來到我的文章！希望這篇文章可以幫助你更理解 JavaScript 的程式執行順序，理解為什麼這段程式碼跑完後，順序會是 A → C → B。\n在了解執行順序之前，我們需要先認識 JavaScript 是如何處理程式碼的。\n同步與非同步的概念 在 JavaScript 中，程式碼的執行方式可以分為同步（Synchronous）和非同步（Asynchronous）兩種：\n同步程式碼（Synchronous）：程式碼會按照撰寫的順序逐行執行，當一個函式正在執行時，其他程式碼必須等它執行完畢後才能繼續。 非同步程式碼（Asynchronous）：某些操作可能會花費較長的時間（例如 I/O 操作、網路請求、計時器等），這些操作不會阻塞主執行緒，而是會在背景執行，等到完成後才通知 JavaScript 執行對應的回調函式。 想像你去一家早餐店點餐 同步就是你排隊點了一份三明治，然後站在櫃檯前等老闆做好才離開。這時候老闆只能處理你的訂單，無法同時幫其他客人做餐點。如果餐點需要 5 分鐘，所有其他客人都得等你先拿到才輪到他們。\n而非同步則是你先點了三明治，老闆告訴你「等一下，我做好會叫你」，然後繼續幫其他客人點餐。當你的三明治做好時，老闆才喊你的號碼，你再過去拿餐。這個情境下，其他客人不需要等你拿到餐點，大家的服務變得更有效率。\n在 JavaScript 中：\n同步程式碼 就像「站在櫃檯等老闆做好三明治」，所有程式碼會按照順序執行，直到當前的執行完成，才能繼續下一步。 非同步程式碼 則像「點完餐後先去做別的事，等三明治做好了再來拿」，這樣 JavaScript 可以處理更多請求，而不會因為等待某個結果而卡住。 Call Stack（呼叫堆疊） JavaScript 採用單線程（single-threaded）模型，代表它一次只能執行一個任務。如果有多個任務要執行時，這些任務們就必須要排隊，等待 JavaScript 執行到他們。\n那這些任務會在哪裡排隊呢？通常來說，同步程式碼都會被放到一個叫 Call Stack（呼叫堆疊）的地方等待被執行。舉一個簡單的例子來說：\n1 2 console.log(\u0026#34;A\u0026#34;); console.log(\u0026#34;B\u0026#34;); 這時候程式碼的運作會像是這樣：\n如果程式碼都是這樣執行的話，為什麼一開始的例子，setTimeout 裡的內容會是最後才出現呢？\nTask Queue（任務佇列） 這是因為非同步的程式碼排隊的地方和同步的程式碼不同。非同步的程式碼通常會有一個 callback function，而他會被放到 Task Queue（任務佇列）裡等待，當 Call Stack 沒有任務要執行時，他才會被取出來，放到 Call Stack 裡被執行。舉例來說：\n1 2 3 4 5 6 7 8 9 10 11 console.log(\u0026#34;A\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;B\u0026#34;); }, 0); setTimeout(() =\u0026gt; { console.log(\u0026#34;C\u0026#34;); }, 0); console.log(\u0026#34;D\u0026#34;); 執行順序會是：\n那誰會負責處理 Call Stack 裡面的任務？又是誰負責把 Task Queue 裡面的任務移動到 Call Stack 內讓他們被執行的？\nEvent Loop（事件迴圈） Event Loop（事件迴圈）是 JavaScript 的核心機制之一，負責監控 Call Stack 和 Task Queue，確保非同步程式碼能夠正確執行。\n而 Event Loop 會幫忙做這些事情：\n先執行 Call Stack 裡的所有同步程式碼 如果 Call Stack 清空了，Event Loop 會檢查 Microtask Queue（例如 Promise.then()），如果有，則執行 當 Microtask Queue 清空後，Event Loop 會檢查 Task Queue，並將第一個等待的回調函式推入 Call Stack 執行 重複這個過程，確保所有程式碼依照適當的順序執行 我們在上面有提到 Call Stack 和 Task Queue，那 Microtask Queue 又是什麼？\nMicrotask Queue（微任務佇列） 除了 Task Queue 之外，還有一個優先級別更高的佇列：Microtask Queue（微任務佇列）。會在這裡排隊的任務也都是非同步程式碼，在這之中會有我們很常使用到的一個人：Promise.then()。一樣讓我們用一個簡單的例子來看一下：\n1 2 3 4 5 6 7 8 9 10 11 console.log(\u0026#34;A\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;B\u0026#34;); }, 0); Promise.resolve().then(() =\u0026gt; { console.log(\u0026#34;C\u0026#34;); }); console.log(\u0026#34;D\u0026#34;); 總結 讓我們來回顧一下這篇文章我們學到了什麼：\n同步程式碼 就像在隊伍裡排隊結帳，一行一行地執行，進入 Call Stack，跑完後才換下一個 非同步程式碼（像 setTimeout）會被交給 Web API 處理，等它們準備好，才會被放回來，排隊等著執行 Microtask Queue（像 Promise.then()）的優先級比 Task Queue 高，會先執行，所以 Promise.then() 會比 setTimeout(..., 0) 先跑 Event Loop 就像 JavaScript 的調度員，負責監控 Call Stack 和 Task Queue，確保大家按順序執行，不會亂掉 那麼現在，你可以理解為什麼這段程式碼被印出來的順序是 A → C → B 了嗎？😉\n1 2 3 4 5 6 7 console.log(\u0026#34;A\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;B\u0026#34;); }, 0); console.log(\u0026#34;C\u0026#34;); ","date":"2025-03-09T21:00:00+08:00","permalink":"https://anthea-wu.github.io/post/javascript-%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E4%BF%AE%E8%A1%8C%E4%B9%8B%E8%B7%AF1/","title":"JavaScript 工程師的修行之路（1）"},{"content":"在 JavaScript 的世界裡，處理異步操作的方法有多種，其中最常被討論的就是 async/await 與 Promise.then()。這兩者各有特色與適用場景，理解它們的差異，有助於我們在開發中做出更明智的選擇。\n接下來我將會從語法風格、錯誤處理、執行順序這三個面向說明一下兩者的差異。\n語法風格與可讀性 async/await 的出現，讓我們可以用類似同步的方式來撰寫異步程式碼，提升了程式的可讀性。例如：\n1 2 3 4 5 6 7 8 9 async function fetchData() { try { const response = await fetch(\u0026#34;https://api.example.com/data\u0026#34;); const data = await response.json(); console.log(data); } catch (error) { console.error(\u0026#34;發生錯誤：\u0026#34;, error); } } 相比之下，使用 Promise.then() 的寫法則是：\n1 2 3 4 5 6 7 8 9 10 function fetchData() { fetch(\u0026#34;https://api.example.com/data\u0026#34;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { console.log(data); }) .catch(error =\u0026gt; { console.error(\u0026#34;發生錯誤：\u0026#34;, error); }); } 從上述例子可以看出，async/await 讓程式碼結構更接近同步邏輯，減少了巢狀結構，提升了可讀性。然而，Promise.then() 在非 async 的環境中仍然適用，且在某些情境下可能更為直觀。\nCallback Hell 問題 在使用 Promise.then() 時，如果多個異步操作有依賴關係，可能會導致 Callback Hell（回調地獄）。當回調函式過度巢狀時，程式碼變得難以閱讀與維護。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function fetchUserData(userId) { fetch(`https://api.example.com/user/${userId}`) .then(response =\u0026gt; response.json()) .then(user =\u0026gt; { fetch(`https://api.example.com/orders/${user.id}`) .then(response =\u0026gt; response.json()) .then(orders =\u0026gt; { fetch(`https://api.example.com/order-details/${orders[0].id}`) .then(response =\u0026gt; response.json()) .then(orderDetails =\u0026gt; { console.log(\u0026#34;訂單詳細資料:\u0026#34;, orderDetails); }) .catch(error =\u0026gt; console.error(\u0026#34;獲取訂單詳情失敗:\u0026#34;, error)); }) .catch(error =\u0026gt; console.error(\u0026#34;獲取訂單失敗:\u0026#34;, error)); }) .catch(error =\u0026gt; console.error(\u0026#34;獲取使用者失敗:\u0026#34;, error)); } 這種嵌套的 .then() 結構會導致：\n難以閱讀與維護：每個異步操作都巢狀在前一個 .then() 內部，增加了理解成本。 錯誤處理複雜：每一層 .then() 都可能發生錯誤，處理起來相當麻煩。 如何用 async/await 解決 Callback Hell？ async/await 可以讓程式碼變得更直覺，避免過度巢狀：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 async function fetchUserData(userId) { try { const userResponse = await fetch(`https://api.example.com/user/${userId}`); const user = await userResponse.json(); const ordersResponse = await fetch(`https://api.example.com/orders/${user.id}`); const orders = await ordersResponse.json(); const orderDetailsResponse = await fetch(`https://api.example.com/order-details/${orders[0].id}`); const orderDetails = await orderDetailsResponse.json(); console.log(\u0026#34;訂單詳細資料:\u0026#34;, orderDetails); } catch (error) { console.error(\u0026#34;發生錯誤：\u0026#34;, error); } } 這樣的寫法讓程式碼結構更清晰，且可以透過 try…catch 統一處理錯誤，減少 Callback Hell 的問題。\n錯誤處理 在使用 async/await 時，我們通常透過 try…catch 來進行錯誤處理，這使得錯誤處理邏輯更為集中：\n1 2 3 4 5 6 7 8 9 async function fetchData() { try { const response = await fetch(\u0026#34;https://api.example.com/data\u0026#34;); const data = await response.json(); console.log(data); } catch (error) { console.error(\u0026#34;發生錯誤：\u0026#34;, error); } } 而使用 Promise.then() 時，則是透過 .catch() 來捕捉錯誤：\n1 2 3 4 5 6 7 8 9 10 function fetchData() { fetch(\u0026#34;https://api.example.com/data\u0026#34;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { console.log(data); }) .catch(error =\u0026gt; { console.error(\u0026#34;發生錯誤：\u0026#34;, error); }); } 需要注意的是，await 會等待 Promise 解決後再繼續執行，這意味著它會暫停所在的 async 函式的執行；而 Promise.then() 則是在將回調函式加入回調鏈後，繼續執行當前函式。\n執行順序 使用 await 時，需要注意可能導致的順序執行問題。例如，以下程式碼會依次等待每個 fetch 完成，導致總耗時增加：\n1 2 3 4 5 async function fetchData() { const data1 = await fetch(url1); const data2 = await fetch(url2); // 處理 data1 和 data2 } 為了提高效率，我們可以使用 Promise.all 來並行執行多個異步操作：\n1 2 3 4 async function fetchData() { const [data1, data2] = await Promise.all([fetch(url1), fetch(url2)]); // 處理 data1 和 data2 } 這樣可以同時發送多個請求，縮短總的執行時間。\n總結 為了更清楚地比較 async/await 與 Promise 的差異，我們可以用表格來整理它們的優缺點：\n以上就是今天的分享，我們下篇文章見 👋🏻\n","date":"2025-03-09T15:30:00+08:00","permalink":"https://anthea-wu.github.io/post/javascript-journey-2/","title":"JavaScript 工程師的修行之路（2）"},{"content":"SignalR Groups 簡介 延續上一篇文章介紹的 SignalR 聊天室概念，這次要來聊聊「小房間」功能。如果你熟悉 Discord，可以把 SignalR Groups 想像成 Discord 的語音或文字頻道，每個頻道就是一個 Group，使用者可以進出不同的頻道來交流。\nSignalR 的 Groups 讓我們可以把連接的使用者分成不同的「小房間」，用來實現群組聊天、特定用戶廣播等功能。每個使用者可以同時在多個房間裡，這讓訊息傳遞變得很彈性。\nGroups 主要特點 動態管理：你可以隨時讓使用者加入或退出房間，像是隨時加入或離開 Discord 頻道一樣。\n臨時性：房間成員資料只存在伺服器記憶體裡，伺服器重啟後就會清空，不用擔心長期維護。\n廣播效率：可以一次把訊息發給整個房間的人，不需要重複發送。\n多組成員：同一個使用者可以同時待在很多房間，就像你可以加入好幾個 Discord 頻道一樣。\n實作步驟 1. 服務器端實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 using Microsoft.AspNetCore.SignalR; namespace WebApiDemo.Hubs; public class ChatHub : Hub { // 使用 Dictionary 追踪用戶所在的房間 private static readonly Dictionary\u0026lt;string, string\u0026gt; UserRooms = new(); private static readonly string[] SensitiveWords = new[] { \u0026#34;討厭\u0026#34;, \u0026#34;笨蛋\u0026#34;, \u0026#34;白痴\u0026#34; }; // 前置需求：記得在 Program.cs 中設定 SignalR 服務 // builder.Services.AddSignalR(); // app.MapHub\u0026lt;ChatHub\u0026gt;(\u0026#34;/chatHub\u0026#34;); // 加入房間的方法 public async Task JoinRoom(string user, string roomName) { // 檢查用戶是否已在其他房間 if (UserRooms.TryGetValue(Context.ConnectionId, out string? oldRoom)) { // 從舊房間移除 await Groups.RemoveFromGroupAsync(Context.ConnectionId, oldRoom); // 通知舊房間的其他用戶 await Clients.Group(oldRoom).SendAsync(\u0026#34;ReceiveSystemMessage\u0026#34;, $\u0026#34;用戶 {user} 離開了房間\u0026#34;); } // 將用戶加入新房間 await Groups.AddToGroupAsync(Context.ConnectionId, roomName); // 更新用戶房間記錄 UserRooms[Context.ConnectionId] = roomName; // 通知新房間的所有用戶 await Clients.Group(roomName).SendAsync(\u0026#34;ReceiveSystemMessage\u0026#34;, $\u0026#34;用戶 {user} 加入了房間\u0026#34;); } public async Task SendMessage(string user, string message) { if (ContainsSensitiveWords(message, out string foundWord)) { await Clients.Caller.SendAsync(\u0026#34;ReceiveSystemMessage\u0026#34;, $\u0026#34;消息包含敏感詞「{foundWord}」，已被攔截\u0026#34;); return; } // 檢查用戶所在的房間 if (UserRooms.TryGetValue(Context.ConnectionId, out string? room)) { // 只向同一房間的用戶發送消息 await Clients.Group(room).SendAsync(\u0026#34;ReceiveMessage\u0026#34;, user, message); } } private bool ContainsSensitiveWords(string message, out string foundWord) { foundWord = SensitiveWords.FirstOrDefault(word =\u0026gt; message.Contains(word, StringComparison.OrdinalIgnoreCase)); return foundWord != null; } // 當新客戶端連接時觸發 public override async Task OnConnectedAsync() { // Context.ConnectionId: 每個連接的唯一標識 await Clients.All.SendAsync(\u0026#34;UserConnected\u0026#34;, Context.ConnectionId); await base.OnConnectedAsync(); } // 當客戶端斷開連接時觸發 public override async Task OnDisconnectedAsync(Exception? exception) { // 用戶斷開連接時清理房間資訊 if (UserRooms.TryGetValue(Context.ConnectionId, out string? room)) { await Groups.RemoveFromGroupAsync(Context.ConnectionId, room); UserRooms.Remove(Context.ConnectionId); } await Clients.All.SendAsync(\u0026#34;UserDisconnected\u0026#34;, Context.ConnectionId); await base.OnDisconnectedAsync(exception); } } Groups 相關的重要方法 Groups.AddToGroupAsync：將使用者加入房間 Groups.RemoveFromGroupAsync：將使用者從房間中移除 Clients.Group：向指定房間的使用者發送消息 2. 客戶端實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;SignalR 聊天室\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #messagesList { border: 1px solid #ccc; height: 300px; overflow-y: auto; padding: 10px; margin-bottom: 10px; } .form-group { margin: 10px 0; } .form-group label { display: inline-block; width: 70px; } .form-group input { padding: 5px; width: 200px; } #sendButton { padding: 5px 15px; margin-top: 10px; } .system-message { color: #ff4444; font-style: italic; margin: 5px 0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;SignalR 聊天室\u0026lt;/h2\u0026gt; \u0026lt;!-- 添加房間選擇 --\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;roomInput\u0026#34;\u0026gt;房間:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;roomInput\u0026#34; /\u0026gt; \u0026lt;button id=\u0026#34;joinButton\u0026#34;\u0026gt;加入房間\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;messagesList\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;userInput\u0026#34;\u0026gt;用戶名:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;userInput\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;messageInput\u0026#34;\u0026gt;消息:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;messageInput\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button id=\u0026#34;sendButton\u0026#34;\u0026gt;發送\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 建立連接 const connection = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;/chatHub\u0026#34;) // Hub 的路由 .build(); document.getElementById(\u0026#34;sendButton\u0026#34;).disabled = true; // 註冊接收消息的處理函數 connection.on(\u0026#34;ReceiveMessage\u0026#34;, function (user, message) { const msg = `${user}: ${message}`; const li = document.createElement(\u0026#34;div\u0026#34;); li.textContent = msg; document.getElementById(\u0026#34;messagesList\u0026#34;).appendChild(li); }); // 處理用戶連接事件 connection.on(\u0026#34;UserConnected\u0026#34;, function (connectionId) { const msg = `用戶已連接 (${connectionId})`; const li = document.createElement(\u0026#34;div\u0026#34;); li.textContent = msg; li.style.color = \u0026#34;green\u0026#34;; document.getElementById(\u0026#34;messagesList\u0026#34;).appendChild(li); }); connection.on(\u0026#34;UserDisconnected\u0026#34;, function (connectionId) { const msg = `用戶已斷開連接 (${connectionId})`; const li = document.createElement(\u0026#34;div\u0026#34;); li.textContent = msg; li.style.color = \u0026#34;red\u0026#34;; document.getElementById(\u0026#34;messagesList\u0026#34;).appendChild(li); }); connection.on(\u0026#34;ReceiveSystemMessage\u0026#34;, function (message) { const div = document.createElement(\u0026#34;div\u0026#34;); div.textContent = `系統提示: ${message}`; div.className = \u0026#34;system-message\u0026#34;; document.getElementById(\u0026#34;messagesList\u0026#34;).appendChild(div); }); // 啟動連接 connection.start().then(function () { document.getElementById(\u0026#34;sendButton\u0026#34;).disabled = false; }).catch(function (err) { return console.error(err.toString()); }); // 發送消息 document.getElementById(\u0026#34;sendButton\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function (event) { const user = document.getElementById(\u0026#34;userInput\u0026#34;).value; const message = document.getElementById(\u0026#34;messageInput\u0026#34;).value; // 調用服務器端的 SendMessage 方法 connection.invoke(\u0026#34;SendMessage\u0026#34;, user, message).catch(function (err) { return console.error(err.toString()); }); document.getElementById(\u0026#34;messageInput\u0026#34;).value = \u0026#34;\u0026#34;; event.preventDefault(); }); // 添加加入房間按鈕的處理 document.getElementById(\u0026#34;joinButton\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function (event) { const user = document.getElementById(\u0026#34;userInput\u0026#34;).value; const room = document.getElementById(\u0026#34;roomInput\u0026#34;).value; if (!user || !room) { alert(\u0026#34;請輸入用戶名和房間名\u0026#34;); return; } connection.invoke(\u0026#34;JoinRoom\u0026#34;, user, room); event.preventDefault(); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 測試效果 這時候運行你的專案（你應該有記得在上一篇文章中一起設定過 launchSettings.json 對吧），輸入 localhost:5000/index.html，就可以看到以下的畫面：\n一進入的時候沒有特別指定房間，如果 Anthea 進入到房間（明星三缺一），這時候他的訊息只會發給同一個房間裡的人，沒有進入同一個房間的 Ensui 就收不到訊息了。\n","date":"2025-01-07T21:00:00+08:00","permalink":"https://anthea-wu.github.io/post/%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%9A%84%E5%B0%8F%E6%88%BF%E9%96%93/","title":".NET SignalR 的學習與應用（2）"},{"content":"SignalR 簡介 如果你是第一次接觸 SignalR，可以想像它是一個幫你處理即時通訊的工具。它會自動幫你搞定誰在線上、誰下線了，還能讓你輕鬆把訊息送給所有人或指定的人，而且可以應付很多人同時使用。簡單來說，不用煩惱那些複雜的底層細節，SignalR 幫你包好了！\n傳輸協議 你可能會想問，SignalR 到底怎麼做到讓訊息這麼即時的呢？其實它會自動幫你選擇最適合的傳輸方式：\nWebSocket：就像一直開著的專線，速度最快，也是首選。 Server-Sent Events (SSE)：伺服器主動推消息給你，像訂閱新聞一樣。 Long Polling：不斷問伺服器「有新消息嗎？」來達成即時效果。 不用擔心怎麼挑，SignalR 會幫你搞定！\n實作步驟 1. 建立專案並添加 SignalR 在 .NET Core/.NET 5+ 中，SignalR 已經被整合到 ASP.NET Core 框架中了，所以我們不需要額外安裝 SignalR 的服務器端套件，只需要在 Program.cs 中配置 SignalR：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using WebApiDemo.Hubs; var builder = WebApplication.CreateBuilder(args); // 添加 SignalR 服務到 DI 容器 builder.Services.AddSignalR(); var app = builder.Build(); app.UseStaticFiles(); app.UseRouting(); // 啟用路由 // 配置 SignalR Hub 路由 app.MapHub\u0026lt;ChatHub\u0026gt;(\u0026#34;/chatHub\u0026#34;); // 設置默認頁面 app.MapGet(\u0026#34;/\u0026#34;, () =\u0026gt; Results.File(\u0026#34;wwwroot/index.html\u0026#34;, \u0026#34;text/html\u0026#34;)); app.Run(); 2. 創建 Hub Hub 是 SignalR 的核心角色，可以想成「訊息小幫手」，負責在用戶的瀏覽器和伺服器之間傳遞訊息。基本的 Hub 需要做的事很簡單：收到使用者的訊息並轉送給其他人，處理使用者連線和斷線的通知。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 using Microsoft.AspNetCore.SignalR; namespace WebApiDemo.Hubs; public class ChatHub : Hub { // 這個方法用來接收使用者的訊息並廣播給所有人 public async Task SendMessage(string user, string message) { await Clients.All.SendAsync(\u0026#34;ReceiveMessage\u0026#34;, user, message); } // 使用者連線時會觸發這裡，把新加入的使用者通知給大家 public override async Task OnConnectedAsync() { await Clients.All.SendAsync(\u0026#34;UserConnected\u0026#34;, Context.ConnectionId); await base.OnConnectedAsync(); } // 使用者斷線時會執行這裡，把誰離開的通知發給所有人 public override async Task OnDisconnectedAsync(Exception? exception) { await Clients.All.SendAsync(\u0026#34;UserDisconnected\u0026#34;, Context.ConnectionId); await base.OnDisconnectedAsync(exception); } } Hub 重要屬性 Clients：負責把訊息發送給誰，例如：\nClients.All：送給所有人，不管是誰 Clients.Caller：只回傳給發送訊息的人 Clients.Others：送給除了發訊息的人以外的所有人 Context：提供關於這次連線的資訊，例如：\nContext.ConnectionId：每個使用者連上來後都有一個獨一無二的編號 Context.User：使用者的身份資訊，適用在需要登入或認證的應用程式 3. 客戶端實現 在 root 目錄底下建立 wwwroot 的資料夾，並且建立 index.html 輸入以下內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;SignalR 聊天室\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #messagesList { border: 1px solid #ccc; height: 300px; overflow-y: auto; padding: 10px; margin-bottom: 10px; } .form-group { margin: 10px 0; } .form-group label { display: inline-block; width: 70px; } .form-group input { padding: 5px; width: 200px; } #sendButton { padding: 5px 15px; margin-top: 10px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;SignalR 聊天室\u0026lt;/h2\u0026gt; \u0026lt;div id=\u0026#34;messagesList\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;userInput\u0026#34;\u0026gt;用戶名:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;userInput\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;messageInput\u0026#34;\u0026gt;消息:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;messageInput\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button id=\u0026#34;sendButton\u0026#34;\u0026gt;發送\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 建立連接 const connection = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;/chatHub\u0026#34;) // Hub 的路由 .build(); document.getElementById(\u0026#34;sendButton\u0026#34;).disabled = true; // 註冊接收消息的處理函數 connection.on(\u0026#34;ReceiveMessage\u0026#34;, function (user, message) { const msg = `${user}: ${message}`; const li = document.createElement(\u0026#34;div\u0026#34;); li.textContent = msg; document.getElementById(\u0026#34;messagesList\u0026#34;).appendChild(li); }); // 處理用戶連接事件 connection.on(\u0026#34;UserConnected\u0026#34;, function (connectionId) { const msg = `用戶已連接 (${connectionId})`; const li = document.createElement(\u0026#34;div\u0026#34;); li.textContent = msg; li.style.color = \u0026#34;green\u0026#34;; document.getElementById(\u0026#34;messagesList\u0026#34;).appendChild(li); }); connection.on(\u0026#34;UserDisconnected\u0026#34;, function (connectionId) { const msg = `用戶已斷開連接 (${connectionId})`; const li = document.createElement(\u0026#34;div\u0026#34;); li.textContent = msg; li.style.color = \u0026#34;red\u0026#34;; document.getElementById(\u0026#34;messagesList\u0026#34;).appendChild(li); }); // 啟動連接 connection.start().then(function () { document.getElementById(\u0026#34;sendButton\u0026#34;).disabled = false; }).catch(function (err) { return console.error(err.toString()); }); // 發送消息 document.getElementById(\u0026#34;sendButton\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function (event) { const user = document.getElementById(\u0026#34;userInput\u0026#34;).value; const message = document.getElementById(\u0026#34;messageInput\u0026#34;).value; // 調用服務器端的 SendMessage 方法 connection.invoke(\u0026#34;SendMessage\u0026#34;, user, message).catch(function (err) { return console.error(err.toString()); }); document.getElementById(\u0026#34;messageInput\u0026#34;).value = \u0026#34;\u0026#34;; event.preventDefault(); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 這時候運行你的專案（記得設定 launchSettings.json），輸入 localhost:5000/index.html，就可以看到以下的畫面。\n如果你再多開一個新的 tab，就會看到第一個 tab 多了一行連接的用戶：\n兩個不同的人可以輸入訊息，按下發送後，另外一邊也會收到：\n有人離開的話就可以送出通知：\n","date":"2025-01-04T21:00:00+08:00","permalink":"https://anthea-wu.github.io/post/%E7%B0%A1%E5%96%AE%E7%B6%B2%E9%A0%81%E8%81%8A%E5%A4%A9%E5%AE%A4/","title":".NET SignalR 的學習與應用（1）"},{"content":"上一篇提到基本的下拉式選單應用之後，接下來要記錄的是多個選單彼此連動時的應用。\n以前一篇工作上的例子來說，通常把資料用縣市、鄉鎮市區、地段這三種層級區分開來，所以當我選到台北市的時候，鄉鎮市區的選單裡就不應該會出現西屯區的項目，這個就是我所謂的連動 — — 當其中一個選項的值改變，就會讓其他的選單內容也跟著不同。\n事前準備 簡單的 API 清單來源一樣是地籍圖資網路便民服務系統，我只整理了台中市的西屯區和西區這兩個行政區底下的段名作為範例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 using Microsoft.AspNetCore.Mvc; using Newtonsoft.Json; namespace bootstrap_selected_sample.Controllers; [ApiController] [Route(\u0026#34;api/[controller]\u0026#34;)] public class CodeController : ControllerBase { [HttpGet] public IActionResult Counties() { var path = \u0026#34;files/county.json\u0026#34;; var json = ReadFromJson(path); var info = JsonConvert.DeserializeObject\u0026lt;List\u0026lt;SimpleInfo\u0026gt;\u0026gt;(json); return Ok(info); } [HttpGet(\u0026#34;{county}\u0026#34;)] public IActionResult Towns(string county) { var path = county.ToUpper() switch { \u0026#34;B\u0026#34; =\u0026gt; \u0026#34;files/taichung.json\u0026#34; }; var json = ReadFromJson(path); var info = JsonConvert.DeserializeObject\u0026lt;List\u0026lt;SimpleInfo\u0026gt;\u0026gt;(json); return Ok(info); } [HttpGet(\u0026#34;{county}/{town}\u0026#34;)] public IActionResult Sections(string county, string town) { var path = \u0026#34;\u0026#34;; switch (county) { case \u0026#34;B\u0026#34; when town == \u0026#34;06\u0026#34;: path = \u0026#34;files/xitun.json\u0026#34;; break; case \u0026#34;B\u0026#34; when town == \u0026#34;04\u0026#34;: path = \u0026#34;files/xi.json\u0026#34;; break; } var json = ReadFromJson(path); var info = JsonConvert.DeserializeObject\u0026lt;List\u0026lt;ComplexInfo\u0026gt;\u0026gt;(json); return Ok(info); } private string ReadFromJson(string path) { var reader = new StreamReader(path); var readToEnd = reader.ReadToEnd().Replace(\u0026#34;\\r\u0026#34;, \u0026#34;\u0026#34;).Replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;).Replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;); return readToEnd; } } public class SimpleInfo { public string Id { get; set; } public string Name { get; set; } } public class ComplexInfo : SimpleInfo { public string OfficeCode { get; set; } } 套用 bootstrap-select 首先，我們依照上次的方法，使用 Vue.$nextTick() 來試試看效果怎麼樣。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;!-- sample.html --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34; class=\u0026#34;container my-5\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-12 mt-5 row\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;div class=\u0026#34;row g-3 align-items-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-auto\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;county-select\u0026#34; class=\u0026#34;col-form-label\u0026#34;\u0026gt;縣市\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-auto\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;county-select\u0026#34; v-model=\u0026#34;selected.county\u0026#34;\u0026gt; \u0026lt;option v-for=\u0026#34;c in code.county\u0026#34; :value=\u0026#34;c\u0026#34;\u0026gt;{{c.name}}\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-auto\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;county-select\u0026#34; class=\u0026#34;col-form-label\u0026#34;\u0026gt;鄉鎮市區\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-auto\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;town-select\u0026#34; v-model=\u0026#34;selected.town\u0026#34;\u0026gt; \u0026lt;option v-for=\u0026#34;t in code.town\u0026#34; :value=\u0026#34;t\u0026#34;\u0026gt;{{t.name}}\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-auto\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;county-select\u0026#34; class=\u0026#34;col-form-label\u0026#34;\u0026gt;地段\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-auto\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;section-select\u0026#34; v-model=\u0026#34;selected.section\u0026#34;\u0026gt; \u0026lt;option v-for=\u0026#34;s in code.section\u0026#34; :value=\u0026#34;s\u0026#34;\u0026gt;{{s.name}}\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-12 mt-3 row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-4\u0026#34; v-if=\u0026#34;selected.county !== null \u0026amp;\u0026amp; selected.town !== null \u0026amp;\u0026amp; selected.section !== null\u0026#34;\u0026gt; 已經選擇：{{selected.county.name}} {{selected.town.name}} {{selected.section.name}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // sample.js const app = Vue.createApp({ data(){ return{ code:{ county: [], town: [], section: [] }, selected:{ county: null, town: null, section: null } } }, methods:{ getCounties(){ this.selected.county = null; this.selected.town = null; this.selected.section = null; axios({ method: \u0026#39;get\u0026#39;, url: \u0026#39;./api/code\u0026#39; }).then(res =\u0026gt; { this.code.county = res.data; Vue.nextTick(() =\u0026gt; { $(\u0026#39;#county-select\u0026#39;).selectpicker(); }) }) }, getTowns(){ this.selected.town = null; this.selected.section = null; axios({ method: \u0026#39;get\u0026#39;, url: `./api/code/${this.selected.county.id}` }).then(res =\u0026gt; { this.code.town = res.data; Vue.nextTick(() =\u0026gt; { $(\u0026#39;#town-select\u0026#39;).selectpicker(); }) }) }, getSections(){ this.selected.section = null; axios({ method: \u0026#39;get\u0026#39;, url: `./api/code/${this.selected.county.id}/${this.selected.town.id}` }).then(res =\u0026gt; { this.code.section = res.data; Vue.nextTick(() =\u0026gt; { $(\u0026#39;#section-select\u0026#39;).selectpicker(); }) }) }, }, watch:{ \u0026#39;selected.county\u0026#39;: function (newVal) { if (newVal === \u0026#39;\u0026#39; || newVal === null) return; this.getTowns(); }, \u0026#39;selected.town\u0026#39;: function (newVal) { if (newVal === \u0026#39;\u0026#39; || newVal === null) return; console.log(newVal); this.getSections(); }, }, mounted(){ this.getCounties(); } }); app.mount(\u0026#39;#app\u0026#39;); 執行之後你應該可以發現兩個問題：還沒有初始化過的選單會長的很醜，和我們預期的樣式不太一樣，以及，我明明資料內容更新了，但為甚麼畫面上仍然是舊的資料呢？我的資料又去哪裡了 😠\nRefresh UI 在官方文件 Methods 的頁面中，可以看到有一個叫做 refresh 的方法，這個方法可以讓我們更新畫面上的 UI 呈現：\n既然官方都提供了這個用法，那我們就依照建議修改一下程式碼吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // sample.js const app = Vue.createApp({ data(){...}, methods:{ getCounties(){ axios({ method: \u0026#39;get\u0026#39;, url: \u0026#39;./api/code\u0026#39; }).then(res =\u0026gt; { this.code.county = res.data; // 記得要包在 Vue.nextTick() 中才有效喔 Vue.nextTick(() =\u0026gt; { $(\u0026#39;#county-select\u0026#39;).selectpicker(\u0026#39;refresh\u0026#39;); // 更新 county $(\u0026#39;#town-select\u0026#39;).selectpicker(\u0026#39;refresh\u0026#39;); // 更新 town $(\u0026#39;#section-select\u0026#39;).selectpicker(\u0026#39;refresh\u0026#39;); // 更新 section }) }) }, getTowns(){...}, getSections(){...}, }, watch:{...}, mounted(){ this.getCounties(); // 一次全部初始化 Vue.nextTick(() =\u0026gt; { $(\u0026#39;select\u0026#39;).selectpicker(); }) } }); app.mount(\u0026#39;#app\u0026#39;); 資料看起來有被正確的更新到 UI 上了，但為甚麼我的清單看起來還是怪怪的咧 😵\n其實，在官方的完整範例中，是先找到要刪除的選項，移除之後才進行 refresh，但不曉得為甚麼，就算按照官方的範例我也無法正常移除 😵\n用 Destoy 修正 所以最後我採用的方法，是直接把整個元件 destroy 掉，更新資料的時候再重新建立一個。\n1 2 3 4 5 6 7 8 9 10 11 Vue.nextTick(() =\u0026gt; { // 先銷毀再重建 $(\u0026#39;#county-select\u0026#39;).selectpicker(\u0026#39;destroy\u0026#39;); $(\u0026#39;#county-select\u0026#39;).selectpicker(); $(\u0026#39;#town-select\u0026#39;).selectpicker(\u0026#39;destroy\u0026#39;); $(\u0026#39;#town-select\u0026#39;).selectpicker(); $(\u0026#39;#section-select\u0026#39;).selectpicker(\u0026#39;destroy\u0026#39;); $(\u0026#39;#section-select\u0026#39;).selectpicker(); }) 終於可以看到正確的資料有被好好地呈現在 UI 上了 🎊\n參考文章\nbootstrap-select 官方文件 ","date":"2022-08-14T01:13:23+08:00","permalink":"https://anthea-wu.github.io/post/vue-selected-dropdown-2/","title":"可以查詢的下拉式選單 (2)"},{"content":"在工作上，基本都需要針對儲存的資料進行分類，而在地理資訊的領域上，最常使用的一種分類方式就是地籍，又可以細分為縣市、鄉鎮市區、地段等資訊。針對這些分類的名稱，特別是地段的層級，通常都會有幾十筆資料，如果單純使用下拉式選單，就會把時間浪費在茫茫字海裡面進行搜尋。\n如果使用的前端有搭配 Bootstrap 框架，通常會查詢到 bootstrap-select 這個好用的套件 😆 接下來就讓我們看一下搭配簡單的 API ，要怎麼把 bootstrap-select 和 Vue 一起使用吧。\n準備資料並建立 API 利用地籍圖資網路便民服務系統取得相關的縣市鄉鎮清單後，整理成 JSON 檔，再使用 API 的方式把資料傳送到前端。作為簡單的示範，我只有整理出台中市西屯區以及新北市三峽區底下的所有地段號。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 using Microsoft.AspNetCore.Mvc; using Newtonsoft.Json; namespace bootstrap_selected_sample.Controllers; [ApiController] [Route(\u0026#34;api/[controller]\u0026#34;)] public class CodeController : ControllerBase { [HttpGet] public IActionResult Counties() { var path = \u0026#34;files/county.json\u0026#34;; var json = ReadFromJson(path); var info = JsonConvert.DeserializeObject\u0026lt;List\u0026lt;SimpleInfo\u0026gt;\u0026gt;(json); return Ok(info); } private string ReadFromJson(string path) { var reader = new StreamReader(path); var readToEnd = reader.ReadToEnd().Replace(\u0026#34;\\r\u0026#34;, \u0026#34;\u0026#34;).Replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;).Replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;); return readToEnd; } } public class SimpleInfo { public string Id { get; set; } public string Name { get; set; } } 載入套件 方便起見，下面的範例都會使用直接引入 CDN 的方式。另外要注意的是，在 bootstrap-select 官方網站上所提供的 CDN 版本是搭配 bootstrap 4.X，如果你是使用 bootstrap 5 的話，要記得到 bootstrap-select 的 GitHub 查看最新版本的 CDN 網址喔。以下是我使用到的套件和版本：\nName Version Bootstrap 5.0.2 (css + js) bootstrap-select 1.14.0-beta3 (css + js) Vue.js 3 jQuery 3.6.0 axios 無指定版本 使用 bootstrap-select 接下來就要開始使用 bootstrap-select 了。按照官方文件的寫法，最快的方法是直接在 select 中加入 selectpicker 的 class 屬性，或是使用 JavaScript 來進行初始化：\n1 $(\u0026#39;#county-select\u0026#39;).selectpicker(); 大致上知道怎麼使用後，接著我們要加入 API 所回傳的資料，首先試試看最簡單的全台縣市清單吧！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!-- sample.html --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34; class=\u0026#34;container my-5\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-12 mt-5 row\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;div class=\u0026#34;row g-3 align-items-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-auto\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;county-select\u0026#34; class=\u0026#34;col-form-label\u0026#34;\u0026gt;縣市\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-auto\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;county-select\u0026#34; class=\u0026#34;selectpicker\u0026#34;\u0026gt; \u0026lt;option v-for=\u0026#34;c in code.county\u0026#34; :value=\u0026#34;c.code\u0026#34;\u0026gt;{{c.name}}\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // sample.js const app = Vue.createApp({ data(){ return{ code:{ county: [] }, selected:{ county: null } } }, methods:{ getCounties(){ axios({ method: \u0026#39;get\u0026#39;, url: \u0026#39;./api/code\u0026#39; }).then(res =\u0026gt; { this.code.county = res.data; $(\u0026#39;#county-select\u0026#39;).selectpicker(); }) }, }, mounted(){ this.getCounties(); } }); app.mount(\u0026#39;#app\u0026#39;); 當你照著打上面的內容並且開啟網頁之後，你應該會看到你的下拉式選單裡面甚麼都沒有，並且也沒有任何的錯誤訊息。\n我的清單去哪裡了 （以下皆為我的理解，如果有誤還請各位大大不吝指正。）\n會造成這個結果，我的猜測是因為 Vue 的生命週期的緣故。被包在 Vue 掛載範圍內的 html 內容，會在 app.mount('#app') 執行之後，才正式的被放到 DOM 元件上，但在這之前，你的 $('#county-select').selectpicker(); 會先幫你把下拉式選單初始化，可是這個時候其實還沒有真正的把資料利用 v-for 放入下拉式選單的內容中，所以 bootstrap-select 認為這是一個空的選單，自然而然初始化的結果就會是空的了。\n要解決這個問題，可以使用 Vue 中的一個 function nextTick()。他會在整個 DOM 都掛載完成之後，才去進行寫在 nextTick() 內的程式碼。原本的用意其實是在於非同步更新，節省效能。\n使用 nextTick() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // sample.js const app = Vue.createApp({ data(){ return{ code:{ county: [] }, selected:{ county: null } } }, methods:{ getCounties(){ axios({ method: \u0026#39;get\u0026#39;, url: \u0026#39;./api/code\u0026#39; }).then(res =\u0026gt; { this.code.county = res.data; // 原本的程式碼 // $(\u0026#39;#county-select\u0026#39;).selectpicker(); // 使用 nextTick() 包起來 Vue.nextTick(() =\u0026gt; { $(\u0026#39;#county-select\u0026#39;).selectpicker(); }) }) }, }, mounted(){ this.getCounties(); } }); app.mount(\u0026#39;#app\u0026#39;); 利用剛剛學到的 Vue.nextTick() 更新完程式碼之後，你應該就可以順利看到我們成功接回 API 的結果了：\n以上就是基本的 bootstrap-select 使用方式。下一篇會接著介紹更進階的用法，包含如果我要動態的變更下拉式選單，例如：選擇台中市，就只會出現台中的鄉鎮市區選單，會遇到甚麼樣的問題和解法。\n感謝你的收看！\n參考文章\nvue.nextTick()方法的使用詳解 bootstrap-select 官方文件 ","date":"2022-08-07T00:58:03+08:00","permalink":"https://anthea-wu.github.io/post/vue-selected-dropdown-1/","title":"可以查詢的下拉式選單 (1)"},{"content":"前兩篇文章說明了如何讀取 Shapefile，接下來要介紹的是如何生成一個 Shapefile 檔案。\n建立 Shapefile 檔案 在上一篇文章中，我們讀取的檔案包含了三個資訊：ID、土地名稱還有土地面積。所以就按照這個簡單的範例，來建立一個 Shapefile 檔案吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 註冊 MaxRev.Gdal.Core GdalBase.ConfigureAll(); // 註冊 GDAL Gdal.SetConfigOption(\u0026#34;SHAPE_ENCODING\u0026#34;, \u0026#34;big5\u0026#34;); Gdal.AllRegister(); Ogr.RegisterAll(); // 建立 Driver var driver = Ogr.GetDriverByName(\u0026#34;ESRI Shapefile\u0026#34;); var source = driver.CreateDataSource(\u0026#34;files/simple/create.shp\u0026#34;, null); // 座標系統設定 var spatialReference = new SpatialReference(\u0026#34;\u0026#34;); spatialReference.SetWellKnownGeogCS(\u0026#34;WGS84\u0026#34;); // 建立 Field var layer = source.CreateLayer(\u0026#34;layer one\u0026#34;, new SpatialReference(), wkbGeometryType.wkbPolygon, null); var fieldId = new FieldDefn(\u0026#34;Id\u0026#34;, FieldType.OFTInteger); layer.CreateField(fieldId, (int)EnumShapefileColumn.Id); var fieldName = new FieldDefn(\u0026#34;土地名稱\u0026#34;, FieldType.OFTString); layer.CreateField(fieldName, (int)EnumShapefileColumn.Name); var fieldArea = new FieldDefn(\u0026#34;土地面積\u0026#34;, FieldType.OFTString); layer.CreateField(fieldArea, (int)EnumShapefileColumn.Area); // 建立 Feature var field = layer.GetLayerDefn(); var feature = new Feature(field); // 設定內容 feature.SetField((int)EnumShapefileColumn.Id, 1); feature.SetField((int)EnumShapefileColumn.Name, \u0026#34;第二塊土地\u0026#34;); feature.SetField((int)EnumShapefileColumn.Area, \u0026#34;123.4\u0026#34;); // 設定空間資訊 var wkt = \u0026#34;POLYGON ((-1.13755980861244 0.746411483253589,-0.350478468899522 0.488038277511962,-1.06578947368421 -0.028708133971292,-1.13755980861244 0.746411483253589))\u0026#34;; var geometry = Geometry.CreateFromWkt(wkt); feature.SetGeometry(geometry); layer.CreateFeature(feature); Error 1: cannot convert to big5 如果你原封不動把上面的程式碼複製貼上執行的話，應該會遇到第一個錯誤：\n這個錯誤的原因雖然有查詢到相關的討論，但我沒有看的很懂 😢 不過要解決這個問題最簡單的方法就是把第五行的部分進行下面的修改：\n1 2 3 4 5 // 造成錯誤 // Gdal.SetConfigOption(“SHAPE_ENCODING”, “big5”); // 修復 Gdal.SetConfigOption(“SHAPE_ENCODING”, “”); 好的，程式看起來可以順利執行了！不過這樣就會讓前兩篇文章的中文讀取變成亂碼，暫時還沒有更好的解法，所以就先將就一下，把讀寫的註冊分開來吧。\nError 2: 中文亂碼 接下來讓我們用 QGIS 檢視一下我們所產生的 Shapefile 檔案：\n第二個問題出現了，Field 如果使用中文的話會變成亂碼。不過神奇的是，當我們去 QGIS 在的設定中，把 Data Source Encoding 從 UTF-8 調整為 BIG-5 之後，亂碼的情形就反過來了：\n這個問題和上一篇文章中，中文亂碼的問題原因相似，在套件中一個有先被轉為 UTF-8 的編碼，一個沒有，所以造成這樣的情況發生。\n解決中文編碼不同的問題 最一開始以為這個問題很簡單，既然編碼不一樣，那我就先轉好再送進去就應該可以了吧！結果他的編碼是在原生的 dll 裡面進行的，我在外面先轉好一次一樣沒有用……\n於是就想說，既然跟上一篇文章是差不多的問題，那就使用差不多的方式，讀取原生的 method 直接進行調用即可，但卻會一直遇到 Attempted to read or write protected memory. This is often an indication that other memory is corrupt. 的問題，因此也放棄了這個解法。\n最後是查尋到一篇文章，把 feature.SetField 改成調用 SetFieldBinaryFromHexString 就完美的解決問題了！不過方法名稱都明確的顯了要使用 Hex string，所以需要利用下面的方法來把原本的字串稍作轉換：\n1 2 3 4 5 // .NET Core 使用需安裝 Nuget 套件 System.Text.Encoding.CodePages // Encoding.RegisterProvider(CodePagesEncodingProvider.Instance); // 可以加在使用前，或是 Program.cs var bytes = Encoding.GetEncoding(950).GetBytes(\u0026#34;第二塊土地\u0026#34;); var hexString = Convert.ToHexString(bytes); 最後檢視一下我們生產的 Shapefile 檔案，還可以發現兩個小問題：\nError 3: 預設編碼 如果是先轉成 BIG-5 再轉 Hex string，可以發現一開始打開的時候還是亂碼，需要到設定裡面把 Data Source Encoding 調整為 BIG-5 後才能正常顯示。這個部分只需要在建立 Layer 的時候把最後一個參數加上 Encoding 的設定即可：\n1 2 3 4 5 6 // 原本的設定 var layer = source.CreateLayer(\u0026#34;layer one\u0026#34;, new SpatialReference(\u0026#34;\u0026#34;), wkbGeometryType.wkbPolygon, null); // 新增 Encoding 為 BIG-5 var layer = source.CreateLayer(\u0026#34;layer one\u0026#34;, new SpatialReference(\u0026#34;\u0026#34;), wkbGeometryType.wkbPolygon, new[]{\u0026#34;ENCODING=BIG5\u0026#34;}); Error 4: 座標系統 一般來說，Shapefile 必須要有指定的座標系統，沒有的話可能會在讀取上遇到一些問題，造成後續的操作錯誤，例如：轉成 WKT 和現存的資料要進行比對的時候，可能就會因為座標系統的不同而需要進行轉換。\n設定座標系統的方法很簡單：\n1 2 3 4 5 6 7 8 // 原本 var layer = source.CreateLayer(\u0026#34;layer one\u0026#34;, new SpatialReference(), wkbGeometryType.wkbPolygon, new[]{\u0026#34;ENCODING=BIG5\u0026#34;}); // 設定座標系統為 WGS84 var spatialReference = new SpatialReference(\u0026#34;\u0026#34;); spatialReference.SetWellKnownGeogCS(\u0026#34;WGS84\u0026#34;); var layer = source.CreateLayer(\u0026#34;layer one\u0026#34;, spatialReference, wkbGeometryType.wkbPolygon, new[]{\u0026#34;ENCODING=BIG5\u0026#34;}); 最終版程式碼 經過上面的修正和調整之後，完整的程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 註冊 MaxRev.Gdal.Core GdalBase.ConfigureAll(); // 註冊 GDAL Gdal.SetConfigOption(\u0026#34;SHAPE_ENCODING\u0026#34;, \u0026#34;big5\u0026#34;); Gdal.AllRegister(); Ogr.RegisterAll(); // 建立 Driver var driver = Ogr.GetDriverByName(\u0026#34;ESRI Shapefile\u0026#34;); var source = driver.CreateDataSource(\u0026#34;files/simple/create.shp\u0026#34;, null); // 座標系統設定 var spatialReference = new SpatialReference(\u0026#34;\u0026#34;); spatialReference.SetWellKnownGeogCS(\u0026#34;WGS84\u0026#34;); // 建立 Field var spatialReference = new SpatialReference(\u0026#34;\u0026#34;); spatialReference.SetWellKnownGeogCS(\u0026#34;WGS84\u0026#34;); var layer = source.CreateLayer(\u0026#34;layer one\u0026#34;, spatialReference, wkbGeometryType.wkbPolygon, new[]{\u0026#34;ENCODING=BIG5\u0026#34;}); var fieldId = new FieldDefn(\u0026#34;Id\u0026#34;, FieldType.OFTInteger); layer.CreateField(fieldId, (int)EnumShapefileColumn.Id); var fieldName = new FieldDefn(\u0026#34;土地名稱\u0026#34;, FieldType.OFTString); layer.CreateField(fieldName, (int)EnumShapefileColumn.Name); var fieldArea = new FieldDefn(\u0026#34;土地面積\u0026#34;, FieldType.OFTString); layer.CreateField(fieldArea, (int)EnumShapefileColumn.Area); // 建立 Feature var field = layer.GetLayerDefn(); var feature = new Feature(field); // 設定內容 var bytes = Encoding.GetEncoding(950).GetBytes(\u0026#34;第二塊土地\u0026#34;); var hexString = Convert.ToHexString(bytes); feature.SetField((int)EnumShapefileColumn.Id, 1); feature.SetField((int)EnumShapefileColumn.Name, hexString); feature.SetField((int)EnumShapefileColumn.Area, \u0026#34;123.4\u0026#34;); // 設定空間資訊 var wkt = \u0026#34;POLYGON ((-1.13755980861244 0.746411483253589,-0.350478468899522 0.488038277511962,-1.06578947368421 -0.028708133971292,-1.13755980861244 0.746411483253589))\u0026#34;; var geometry = Geometry.CreateFromWkt(wkt); feature.SetGeometry(geometry); layer.CreateFeature(feature); 感謝大家的觀看！有任何錯誤還請各位大大不吝指教，有任何問題也歡迎來信跟我討論喔 😉\n參考文章\ngdal for android 開發包，字段屬性為中文出現亂碼 ","date":"2022-07-31T00:43:50+08:00","permalink":"https://anthea-wu.github.io/post/gdal-shapefile-3/","title":"GDAL 操作 ShapeFile (3)"},{"content":"\n上一篇提到，輸出的結果中，欄位的名稱可以正常顯示，內容的值卻會變成亂碼。\n問題出在哪 上網找解法的時候發現有人遇到相似的狀況，但不同的是，我和對方的亂碼顯示是相反的：他的亂碼會出現在欄位名稱，內容的值反而是正常的。\n雖然狀況有點不相同，但他在閱讀了原始碼後提出了一個觀點：\n對比 GetName 和 GetFieldAsString 兩個函數可以很明顯看出來，GetFieldAsString 通過調用 Ogr.Utf8BytesToString 將返回的 UTF8 編碼的位元組數組以 UTF8 方式解碼為字元串，所以能夠正常顯示；而 GetName 則直接返回字元串（實際上編譯器隱性調用了 Encoding.Default.GetString 解碼為字元串），由於沒有使用 UTF8 解碼導致顯示為亂碼。\n― gis0911178, CSDN / CC 4.0 BY-SA 協議 觀察原始碼 為了證明，我利用反編譯的工具來檢視 Gdal.Core.dll，可以看到像下面這樣的內容：\n從這兩張圖中可以看到，讀取內容值，調用 Feature.GetFieldAsString() 的時候，會將結果進行轉換，Utf8BytesToString() 的內容包含：\n所以從結論來看，他的情況應該是正常的，只是不知道為甚麼我會是相反的狀況：有用 UTF8 解碼的內容，反而會是亂碼 😕\nGdal.Core → MaxRev.Gdal.Core 所以，按照他的假設，應該是要在取得欄位名稱的時候多調用 Utf8BytesToString() 來讓字串正確顯示，但對於我的狀況來說，反而是要把 Utf8BytesToString() 拿掉 😢 但我對於 dll 相關的技能樹是未開通的狀態，所以選擇放棄 Gdal.Core 這個套件，轉而使用另外一個同樣使用 Gdal，但專門開發給 .NET Core 使用的套件－－ MaxRev.Gdal.Core。\n套件的使用方法和原本的 Gdal.Core 一模一樣，只是要在原本的 Gdal.AllRegister(); 之前，加上 GdalBase.ConfigureAll(); 就可以了。更改套件之後運行的結果如下：\n修正中文亂碼 將情境還原之後就可以針對他所提出的方法進行修正了。我選擇最快也最好處理的方法－－直接調用原本 dll 中的方法再另外包一層 UTF8 解碼，完整的程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // 註冊 MaxRev.Gdal.Core GdalBase.ConfigureAll(); // 註冊 GDAL Gdal.SetConfigOption(\u0026#34;SHAPE_ENCODING\u0026#34;, \u0026#34;big5\u0026#34;); Gdal.AllRegister(); Ogr.RegisterAll(); // 開啟 SHP 檔案（0 - 讀取、1 - 讀寫） var source = Ogr.Open(\u0026#34;files/simple/test.shp\u0026#34;, (int)EnumShapefileOpen.ReadOnly); var layerCount = source.GetLayerCount(); for (var i = 0; i \u0026lt; layerCount; i++) { // 讀取圖層 Layer 資訊 var layer = source.GetLayerByIndex(i); var fieldCount = layer.GetLayerDefn().GetFieldCount(); for (var j = 0; j \u0026lt; fieldCount; j++) { var field = layer.GetLayerDefn().GetFieldDefn(j); var fieldName = GetFieldDfnName(field); Console.WriteLine($\u0026#34;欄位{j + 1}. {fieldName}\u0026#34;); } // 讀取要素 Feature Feature feature; while ((feature = layer.GetNextFeature()) != null) { var id = feature.GetFieldAsInteger(0); Console.WriteLine($\u0026#34;內容1. {id}\u0026#34;); var name = feature.GetFieldAsString(1); Console.WriteLine($\u0026#34;內容2. {name}\u0026#34;); var area = feature.GetFieldAsInteger64(2); Console.WriteLine($\u0026#34;內容3. {area}\u0026#34;); var geometry = feature.GetGeometryRef(); geometry.ExportToWkt(out var wkt); Console.WriteLine($\u0026#34;- WKT: {wkt}\u0026#34;); } } static string? Utf8BytesToString(IntPtr ptr) { if (ptr == IntPtr.Zero) return null; var ms = new MemoryStream(); byte b; var ofs = 0; while ((b = Marshal.ReadByte(ptr, ofs++)) != 0) { ms.WriteByte(b); } return Encoding.UTF8.GetString(ms.ToArray()); } // Dll 的位置要注意 [DllImport(\u0026#34;gdal/x64/gdal305.dll\u0026#34;, EntryPoint = \u0026#34;OGR_Fld_GetNameRef\u0026#34;, CallingConvention = CallingConvention.Cdecl)] static extern IntPtr OGR_Fld_GetNameRef(HandleRef handle); static string GetFieldDfnName(FieldDefn fieldDefn) { HandleRef handle = FieldDefn.getCPtr(fieldDefn); IntPtr ptr = OGR_Fld_GetNameRef(handle); return Utf8BytesToString(ptr); } public enum EnumShapefileOpen { ReadOnly } 執行之後就可以看到我們把這個亂碼修好啦！\n參考文章\nC#中使用GDAL3（二）：Windows下读写Shape文件及超详细解决中文乱码问题 ","date":"2022-07-24T23:58:59+08:00","permalink":"https://anthea-wu.github.io/post/gdal-shapefile-2/","title":"GDAL 操作 ShapeFile (2)"},{"content":"雖然公司的產品以 APP 為主，但身為一個後端工程師，名片上掛著 GIS 的頭銜，一些基本的地理資訊技術還是要稍微碰一下的。平常接觸最多的就是有紀錄空間資訊的 Shapefile，會需要進行的操作包含讀取它的空間資訊、每個空間資訊上的屬性，以及利用空間資訊做交集或包含的比對。\n一個 Shape 文件包括三個文件：一個主文件 .shp，一個索引文件 .shx，和一個 dBASE 表 .dbf。\n主文件是一個直接存取，變長度紀錄的文件，其中每個紀錄描述構成一個地理特征 Feature 的所有 vertices 座標值。\n在索引文件中，每條記錄包含對應主文件記錄距離主文件頭開始的偏移量。\ndBASE 表包含 SHP 文件中每一個 Feature 的特徵屬性，表中幾何紀錄和屬性數據之間的一一對應關係是基於記錄數目的 ID。在 dBASE 文件中的屬性記錄必須和主文件中的記錄顺序是相同的。圖形數據和屬性數據通過索引號建立一一對應的關係。\n― gis0911178, CSDN / CC 4.0 BY-SA 協議 我對 Shapefile 的理解也還不透徹，但從上面擷取的文章中可以看出一件事情是：一個正常的 Shapefile 檔案必須至少包含三個副檔名的檔案，而其中在我的工作上，會需要取得的資料，一是在 .shp 中記錄的空間資訊，二是在 .dbf 中記錄的其他屬性。不過要注意的是，.shp 檔案是無法單獨被讀取的，如果要對 Shapefile 進行任何操作，同一個資料夾 底下就必須同時存在上面所提到的三個檔案，才能夠順利讀取。\nDotSpatial V.S. GDAL: why GDAL? 前輩留下來的程式碼中，使用的都是 DotSpatial 這個套件，所以一開始我也跟著使用。但後來在執行程式的過程中，時不時會遇到一個奇怪的問題：把相同的程式碼部署在三個不同的環境上，產生出來的 Shapefile Feature 內容會不一樣。\nlocal 端有完整的 100 多個，移到正式環境上卻只剩下不到 10 個 😢 由於一直研究不出個所以然，決定果斷捨棄這個套件，改用今天要介紹的 GDAL。\n安裝套件 .NET Framework 和 .NET 所安裝的 Nuget 套件不太相同：\nNuget Notes .NET Framework Gdal \u0026amp; Gdal.Native 保留 .cs 的 Configuration 檔案就好，移除另一個，並修改 namespace .NET Gdal.Core 讀取 Shapefile 檔案 我利用 QGIS 製作了一個簡單的 Shapefile 檔案，只有一個 Feature，包含的內容如下：\n讀取的程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 註冊 GDAL Gdal.AllRegister(); Ogr.RegisterAll(); // 開啟 SHP 檔案（0 - 讀取、1 - 讀寫） var source = Ogr.Open(\u0026#34;files/simple/test.shp\u0026#34;, (int)EnumShapefileOpen.ReadOnly); var layerCount = source.GetLayerCount(); for (var i = 0; i \u0026lt; layerCount; i++) { // 讀取圖層 Layer 資訊 var layer = source.GetLayerByIndex(i); var fieldCount = layer.GetLayerDefn().GetFieldCount(); for (var j = 0; j \u0026lt; fieldCount; j++) { var field = layer.GetLayerDefn().GetFieldDefn(j); var fieldName = field.GetName(); Console.WriteLine($\u0026#34;欄位{j + 1}. {fieldName}\u0026#34;); } // 讀取要素 Feature Feature feature; while ((feature = layer.GetNextFeature()) != null) { var id = feature.GetFieldAsInteger(0); Console.WriteLine($\u0026#34;內容1. Id: {id}\u0026#34;); var name = feature.GetFieldAsString(1); Console.WriteLine($\u0026#34;內容2. 土地名稱: {name}\u0026#34;); var area = feature.GetFieldAsInteger64(2); Console.WriteLine($\u0026#34;內容3. 土地面積: {area}\u0026#34;); // 轉換成 WKT 的值 var geometry = feature.GetGeometryRef(); geometry.ExportToWkt(out var wkt); Console.WriteLine($\u0026#34;- WKT: {wkt}\u0026#34;); } } public enum EnumShapefileOpen { ReadOnly } 執行結果如下：\n從執行結果中可以發現，明明我在 QGIS 編輯的時候值是中文，到了 C# 這邊卻變成了亂碼。同時，欄位的名稱明明也是中文，卻可以正常地顯示。WHY？\n讓我們在下回分曉。\n參考文章\nC#不用ArcEngine，生成Shp文件(一) — — — — -shapefile数据说明 ","date":"2022-07-24T23:40:41+08:00","permalink":"https://anthea-wu.github.io/post/gdal-shapefile-1/","title":"GDAL 操作 ShapeFile (1)"},{"content":"一般在 IIS 上啟用 https 的步驟很簡單：先匯出憑證要求，接著在收到憑證之後完成憑證要求，在站台上設定新的繫結，將 443 指定到申請的憑證上的域名即可。\n但是，利用 IIS 去向中華電信所申請到的憑證格式為 .cer，在 Nginx 的官網中，使用的卻是 .crt 格式，並且還多了一個一般流程中不會看到的 .key。網路上的教學大多是直接使用 openssl 去生產憑證，由於這個案子是已經有申請好的憑證，所以我們要透過一些方法來把申請到的憑證轉成 Nginx 可以使用的格式。\n在 Nginx 中使用 cer 來設定 https 可以在上面那張圖片中觀察到，有兩個地方的值是粗體的黑字：ssl_certificate 和 ssl_certificate_key，這兩個部分要放的就是憑證的檔案和憑證的私密金鑰。而在這裡會有兩個問題：\n如果是利用 IIS 去產生憑證要求所申請到的憑證，會沒有辦法直接得到私密金鑰，因為他會是加密過後的內容，而 Nginx 要求是不能加密的檔案。 申請所得到的憑證 .cer 沒有辦法直接使用在 Nginx 上。 在看這些問題之前，要先了解一下這幾個檔案的用途和差別：\n名稱 用途 說明 crt 憑證證書 Lunix 系統上的檔案格式 cer 憑證證書 Windows 系統上的檔案格式 key 金鑰 存放公鑰或私鑰 pfx 憑證證書及私鑰 Windows 系統上會把 crt 和私鑰 key 放在同一個檔案內，需要有密碼才能提取 了解了這幾種不同的名詞之後，接下來就是要把我們手上有的 cer 憑證檔案轉換成 Nginx 可以接受的格式。\n1. 匯出 pfx 檔案 第一個步驟，是要藉由 cer 來取得包含憑證證書和私鑰的 pfx 檔案。\nWindows + R 開啟 執行，輸入 mmc 檔案 \u0026gt; 新增或移除嵌入式管理單元，拉到最底下找到 憑證，點選後點擊中間的新增，會跳出另外一個視窗，選擇 電腦帳戶 \u0026gt; 本機電腦，按下完成後視窗會回到 嵌入式管理單元 這一層，確定憑證有被移動到右邊的視窗後就可以按下確定。 在憑證的目錄底下選擇 個人\u0026gt;憑證，如果有先在 IIS 完成憑證要求的話就可以看到原本匯入的憑證，沒有的話請先匯入。找到要匯出 pfx 檔案的憑證對他點選 右鍵 \u0026gt; 所有工作 \u0026gt; 匯出，選擇 是，匯出私密金鑰，點選兩次下一步進入 安全性 的頁面，輸入要存取 pfx 時的密碼。下一步輸入檔名後按下儲存就可以得到 pfx 檔案了。 2. 轉成 crt 檔案 有了 pfx 的下一步就是要轉換成 crt 和 key。轉換的方法很簡單，使用 openssl，輸入下面的指令，就可以得到這兩個檔案了：\n1 2 3 4 5 # 輸出 crt openssl pkcs12 -in server.pfx -clcerts -nokeys -out server.crt # 輸出 key openssl pkcs12 -in server.pfx -nocerts -nodes -out server.rsa 3. 修改 nginx.conf 產出兩個檔案之後就可以進入 nginx.conf 的修改了。修改好記得要 nginx -s reload，防火牆 443 port 的部分也要記得開：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 events { worker_connections 4096; } http { upstream www.abc.com { server localhost:8082; server localhost:8083; } server { # 因為是正式的環境，防火牆也需要申請，所以改成監聽原本 IIS 監聽的 80 port listen 80; server_name www.abc.com; location / { # 將 http 轉導到 https return 301 https://$host$request_uri; } } server { listen 443 ssl; server_name www.abc.com; ssl_certificate server.crt; ssl_certificate_key server.rsa; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://guideapp.npm.gov.tw; # 以下為 proxy 的詳細設置，可以參考下列網站的說明 # https://www.cnblogs.com/kevingrace/p/8269955.html proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } } 參考資料\nNginx 中使用 PFX 格式的 SSL 证书 crt、pem、pfx、cer、key 作用及區別 ","date":"2022-07-02T23:24:03+08:00","permalink":"https://anthea-wu.github.io/post/nginx-web-setup-4/","title":"Nginx 從入門開始的網站架設 (4)"},{"content":"上一篇文章 中我們用最簡單的設定建立起一個靜態服務了，接下來要提到的是 Nginx 最廣為人知的其中一種功能－－代理伺服器（Proxy Server）。\nProxy Server 代理伺服器 有一陣子募資平台很流行，當你有想法但是沒有資金的時候，你可以透過這些平台把你的計劃放上去，吸引一般民眾投入資金，接著拿這些錢去實際生產你的產品，並給當初提供你資金的民眾一些回饋。在這個過程中，募資平台所扮演的角色就是代理：你只能看到資金提供者的提供的寄件資訊，甚至完全不知道他們的身分，但你會負責把你的產品或回饋透過平台提供出去。\n以網路來說，Client（一般民眾）透過代理伺服器（募資平台）發送請求給 Server（你），Server 基本上不會有 Client 的資料，而這就是 Proxy 的好處之一：隱藏 Client 的真實身分。\n其他的好處還有很多，但今天我只想看這次客戶最主要的目的：Load Balance（負載平衡）。\nLoad Balance 負載平衡 Load Balance 的主要目的在於分散伺服器端的壓力，讓伺服器的回應速度和其他效能可以得到提升，使用者能擁有更好的體驗。而要做到這個程度一般來說都會需要依賴剛剛所提到的 proxy 做為中繼站，去判斷現在接收到的這個 request 要被分配到哪一台 server 上。\nNginx 設定 稍微了解 Proxy Server 和 Load Balance 的用途之後，接下來開始試著用 Nginx 來進行設定吧。\nProxy 首先設定好 nginx.conf ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 events { worker_connections 1024; } http { server { listen 8081; server_name localhost; # 以 \u0026#39;/\u0026#39; 開頭的 url 會向 \u0026#39;/data/www\u0026#39; 發送請求 location / { # 設定要導向的路徑 # 如果 IIS 上有設定 8082 port 的站台就會被導向那個站台 proxy_pass http://localhost:8082; } } # IIS 上沒有的站台，設定 8082 port 的內容 server { listen 8082; server_name localhost; # 以 \u0026#39;/\u0026#39; 開頭的 url 會向 \u0026#39;/data/www2\u0026#39; 發送請求 location / { root data/www2; } } } 接著到 /data/www2 底下新增一個新的 index.html，這時候 www 和 www2 的資料夾內各有一個 index.html，上一篇文章中我們會看到 www 內的 index.html，這一次的設定預期會出現的應該是 www2 內的 index.html。\n儲存修改好的 config 之後，nginx -s reload 重新載入檔案，在瀏覽器中輸入 http://localhost:8081 應該就可以看到 www2 中 index.html 的內容囉。\nLoad Balance 要在 Nginx 中使用 Load Balance 需要在 http 中加入 upstream 這組設定，加好之後你的 nginx.conf 應該會長這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 events { worker_connections 1024; } http { # \u0026#39;localhost\u0026#39; 是這組 upstream 的名稱 upstream localhost { # 利用 \u0026#39;weight\u0026#39; 來設定權重 server localhost:8082 weight=1; server localhost:8083 weight=2; } server { listen 8081; server_name localhost; location / { # 這裡要改成 upstream 的名稱 proxy_pass http://localhost; } } server { listen 8082; server_name localhost; location / { # 在 nginx.exe 同一層的資料夾 data 裡面新增一個資料夾 www 和 index.html root data/www; } } server { listen 8083; server_name localhost; location / { # 在 nginx.exe 同一層的資料夾 data 裡面新增一個資料夾 www2 和 index.html root data/www2; } } } 設定好之後 nginx -s reload，瀏覽器打開 http://localhost:8081，持續重新整理，就可以看到交替出現的兩個 index.html 囉~\n參考資料：\n反向代理與正向代理 俄羅斯不愧是戰鬥民族：nginx ","date":"2022-06-23T23:15:50+08:00","permalink":"https://anthea-wu.github.io/post/nginx-web-setup-3/","title":"Nginx 從入門開始的網站架設 (3)"},{"content":"在上一篇文章中我們簡單認識了 nginx 的操作，接下來我們要透過那些操作來建立一個靜態服務。\n1. 準備資料 假設我們的 nginx.exe 位於 nginx 底下，接著我們在這裡新增一個資料夾 data，並在 data 裡面再新增兩個資料夾，分別是 www 和 images，將 index.html 放入 www 資料夾中，將任意的圖片放到 images 資料夾內，這時候你的資料夾結構會像這樣：\n1 2 3 4 5 6 7 8 9 nginx |- nginx.exe |- conf |- data | |- www | | |- index.html | |- images | | |- test.jpg |- ... 2. 修改 nginx.conf 接著開啟你的 nginx.conf，並用下面的內容取代掉原本的設定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 events { worker_connections 1024; } http { server { # 如果電腦上有裝 IIS，預設會占用掉 80 port # 當這裡沒有改成其他 port 號，就算運行了 nginx 也會被帶到 IIS 的畫面去 listen 8081; server_name localhost; # 以 \u0026#39;/\u0026#39; 開頭的 url 會向 \u0026#39;/data/www\u0026#39; 發送請求 location / { # 官方文件上是寫 \u0026#39;/data/www\u0026#39;，但測試過後無法執行 root data/www; } # 以 \u0026#39;/images/\u0026#39; 開頭的 url 會向 \u0026#39;/data\u0026#39; 發送請求 location /images/ { root data; } } } 在設定 location 的時候，如果一個 url 如果有多個相符的區塊，nginx 會選擇具有最長前綴的區塊來發送請求。以上面的例子來說，第一個區塊的前綴是 /，長度為 1，因此當我輸入網址 /books 時，nginx 會幫我從長度更長的 /images 開始比對。這時候因為沒有其他相符的目的地了，所以他會走進最短的 / 裡。\n3. reload nginx.conf 將 nginx.conf 儲存之後，開啟 cmd 將目錄切換到 nginx 的資料夾底下，如果已經啟動過 nginx，執行 nginx -s reload 來重新載入改寫好的 nginx.conf；如果還沒有，輸入 start nginx 來啟動 nginx。\n沒有出現任何錯誤的話，就可以打開瀏覽器，輸入 localhost:8081 就可以看到我們剛剛新增在 /data/www 底下的 index.html 了。\n參考資料\nBeginner’s Guide ","date":"2022-06-17T22:53:49+08:00","permalink":"https://anthea-wu.github.io/post/nginx-web-setup-2/","title":"Nginx 從入門開始的網站架設 (2)"},{"content":"最近有個案子，客戶覺得我們第一次交上去的壓力測試結果太狼狽，要我們想辦法把數字做得更好，於是我們嘗試了 windows 內建的 Network Load Balance（NLB）來進行設定，礙於網路管理的基礎知識不足，遇到了非常多的阻礙 QQ\n最後透過 Nginx 成功做到了 Load Balance，這個系列的文章就是來紀錄順便複習學習到的內容。\nBeginner’s Guide 從 Nginx 的官網上下載下來的檔案內容其實很簡單，只有一個 exe 執行檔和一些資料夾。\nNginx 的運作方式主要是靠 nginx.conf 來決定的，這個檔案通常會在 /usr/local/nginx/conf /etc/nginx /usr/local/etc/nginx 這幾個目錄底下。\n啟動 Nginx 雙擊來執行 nginx.exe 透過 cmd 切換到 nginx 的資料夾底下，執行 start nginx 對 Nginx 進行操作 nginx 被執行起來後就需要以 nginx -s \u0026lt;options\u0026gt; 的方式來控制：\n其中 nginx -s stop 和 nginx -s quit 的差別在於：\nquit - 停止接收 request，等到手上這個 request 處理完之後，才會結束目前的服務 stop - 立刻結束服務 另外， nginx -s quit 只能由開啟 nginx 的使用者（帳號）執行。\n除了 nginx -s stop 之外，最常會用到的應該是 nginx -s reload。\n如果 nginx.conf 有進行修改的話，執行 reload 後主程式才會吃到這個設定的更改。如果主程式設定成功，會通知其他舊有的程式，讓他們停止接收新的 request，將手上的 request 處理完之後結束服務，用新的設定開啟一個新的程式。如果主程式設定失敗的話，會把設定 rollback 成舊的設定並繼續執行。\nconfig 檔案的名詞 在修改 nginx.conf 之前，先來認識一下 config 檔案裏面基本的組成元素：\nsimple directives - 包含指令名稱和參數，兩者之間用半形空白來區隔，並且以半形分號 ; 作為結尾 block directive - 結構和 simple directives 一樣，但他會被半形大括號 {} 包起來 context - 一個 block directive 裡面有其他的 directive，例如 events http server location 都是屬於 context ","date":"2022-06-17T22:41:56+08:00","permalink":"https://anthea-wu.github.io/post/nginx-web-setup-1/","title":"Nginx 從入門開始的網站架設 (1)"},{"content":"今天的重點是在於當我使用了同一個 Interface 的時候，要如何註冊並且分別取得多種實作的部分，因此不會著墨在 Interface 的原理和 DI 的介紹。\n.NET 和 Web API 假設今天有兩種傳送訊息的方式，一種是透過 slack，一種是透過 gmail，在同一個想要同時使用兩種發送方式的話，就會需要使用到 同一個介面註冊多個實作 的方法。\n首先建立兩個 Service，一個是 slack 一個是 gmail，並抽出 interface：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface IMessageService { void Send(); } public class SlackService : IMessageService { public void Send() { Console.WriteLine(\u0026#34;Send By Slack\u0026#34;); } } public class GmailService : IMessageService { public void Send() { Console.WriteLine(\u0026#34;Send By Gmail\u0026#34;); } } 接著我們在 Program.cs 使用 delegate 註冊 Interface，並且告知對應的 key 輸入的時候要回傳哪一個 Service：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers(); builder.Services.AddSingleton\u0026lt;GmailService\u0026gt;(); builder.Services.AddSingleton\u0026lt;SlackService\u0026gt;(); builder.Services.AddSingleton\u0026lt;MessageServiceResolver\u0026gt;(serviceProvider =\u0026gt; key =\u0026gt; { return key switch { \u0026#34;gmail\u0026#34; =\u0026gt; serviceProvider.GetService\u0026lt;GmailService\u0026gt;(), \u0026#34;slack\u0026#34; =\u0026gt; serviceProvider.GetService\u0026lt;SlackService\u0026gt;(), }; }); var app = builder.Build(); app.MapControllers(); app.Run(); public delegate IMessageService MessageServiceResolver(string key); 最後，我們建立一個 Controller，在 Controller 裡使用的時候分辨註冊 Interface，並調用 MessageServiceResolver 來分別取得實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 using Microsoft.AspNetCore.Mvc; namespace WebApplication1.Controllers; [ApiController, Route(\u0026#34;api/[controller]\u0026#34;)] public class TestController : ControllerBase { private readonly IMessageService _gmail; private readonly IMessageService _slack; public TestController(MessageServiceResolver _service) { _slack = _service(\u0026#34;slack\u0026#34;); _gmail = _service(\u0026#34;gmail\u0026#34;); } public void Test() { _slack.Send(); _gmail.Send(); } } 參考資料\nHow To Register Mmultiple Implementations Of The Same Interface In Asp Net Core ","date":"2022-05-25T22:29:58+08:00","permalink":"https://anthea-wu.github.io/post/%E5%90%8C%E4%B8%80%E5%80%8B%E4%BB%8B%E9%9D%A2%E5%A4%9A%E5%80%8B%E5%AF%A6%E4%BD%9C%E7%9A%84%E8%A8%BB%E5%86%8A/","title":"同一個介面多個實作的註冊"},{"content":"最近開始思考有什麼樣的需求可以當作小小的 side project 練習，剛好最近疫情的關係比較多人請假，我就把腦筋動到了請假系統身上。在目前的請假流程中，有一個部分是填寫 google 表單，送出之後會自動新增到 google calendar 上，只要有加入這個日曆的人都可以看到。所以決定以這個為主題，爬了一下文，順便紀錄一下使用 google calendar 的過程。\n使用前的準備 Google API 都是透過 token 來操作的，所以在正式使用前需要先申請好 token，並跟我們自己的 google calendar 連動。\n申請 Token 進入 Google Cloud Platform，預設會幫你建立一個新的專案，如果要更改可以點選畫面上方的 My First Project。不需要的話，直接點選畫面左側的選單，從 API 與服務 中選擇 程式庫。 搜尋 Google Calendar API 並啟用，等 loading 跑完後會出現 管理 的按鈕，或是從選單的 API 與服務 中找到 憑證，點選畫面上方的 新增憑證，選擇 服務帳戶 的選項。 輸入 服務帳戶詳細資料 後按下送出，接著會回到憑證頁面，找到最下面的 服務帳戶 那一列，點選右側的編輯，找到畫面上方的 金鑰，點擊 新增金鑰，選擇 JSON 的格式後按下建立，瀏覽器會自動下載這份檔案，請不要隨意刪除，如果遺失了只能重新產生一份金鑰。 建立 Calerdar 進入 Google Calendar 後選擇一個建立好的日曆，從 設定和共用 進入日曆的設定。 找到 與特定使用者共用日曆 的選項，點選 新增邀請對象。這裡的 email 要輸入剛才那份金鑰 JSON 檔中，client_email_form 的欄位內容，權限要記得調整成 進行變更並管理共用設定。 接著把網頁往下拉，找到 整合日曆 的區塊，記下這個 日曆 ID，接下來會使用到。 到目前為止，需要使用的部分都準備完成了，接下來要進入到程式的部分。\n新增一個活動 新增好一個專案之後，從 Nuget 將 Google.Apis.Calendar.v3 新增到專案內，並加入下列程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 using Google.Apis.Auth.OAuth2; using Google.Apis.Calendar.v3; using Google.Apis.Calendar.v3.Data; using Google.Apis.Services; const string jsonFile = \u0026#34;key.json\u0026#34;; const string calendarId = \u0026#34;id@group.calendar.google.com\u0026#34;; GoogleCredential credential; using var stream = new FileStream(jsonFile, FileMode.Open, FileAccess.Read); credential = GoogleCredential.FromStream(stream).CreateScoped(CalendarService.Scope.Calendar); var service = new CalendarService(new BaseClientService.Initializer { HttpClientInitializer = credential, ApplicationName = \u0026#34;test project\u0026#34;, }); var newEvent = new Event() { Id = Guid.NewGuid().ToString().Replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;), Summary = \u0026#34;Anthea 外出(逢甲大學)\u0026#34;, Start = new EventDateTime() { DateTime = new DateTime(2022, 05, 15, 09, 30, 0), TimeZone = \u0026#34;Asia/Taipei\u0026#34; // Can refer to https://stackoverflow.com/questions/22526635/list-of-acceptable-google-calendar-api-time-zones }, End = new EventDateTime() { DateTime = new DateTime(2022, 05, 15, 10, 30, 0), TimeZone = \u0026#34;Asia/Taipei\u0026#34; } }; var insert = service.Events.Insert(newEvent, calendarId).Execute(); 執行之後回到日歷的頁面，就會看到剛剛新增上去的活動了！\nDebug 紀錄 Invalid resource id value 1 2 3 4 5 6 Google.Apis.Requests.RequestError Invalid resource id value. [400] Errors [ Message[Invalid resource id value.] Location[ - ] Reason[invalid] Domain[global] ] 測試的過程中有出現這個 error，看了官方文件之後發現問題是出在 Event 上，於是選擇另用比較不容易重複的 GUID 去作為參數帶上去。另外，文件上有提到只能使用小寫的英文字母和數字，要記得注意。\n小結 除了範例裡提到的 Insert 之外，基本的 CRUD 都有 API 可以接，但我目前的系統還沒有這部分的功能要實作，所以沒有特別研究。\n另外，官方文件所提供的註冊方法，使用的憑證類別和範例中的不太一樣，我個人認為比較麻煩，所以選擇了服務帳戶的方法。雖然大部分的功能都可以使用，但像是 Event.Attendees 這個邀請參與者的部分，就需要另外設定好權限才可以使用。\n以上就是這次的內容，如果有任何使用上的疑問，或是解釋上的錯誤，都歡迎跟我說喔！我們下次見。\n參考文章\nTimeZone List Google Calendar Api with .NET At least one client secrets (Installed or Web) should be set ","date":"2022-05-14T21:55:35+08:00","permalink":"https://anthea-wu.github.io/post/google-calendar-api/","title":"Google Calendar API"},{"content":"遠端主機已強制關閉一個現存的連線 Server A 一直有一隻運行的很正常的 API 提供給 Server B 和 Server C 呼叫，在某一天忽然 Server B 就呼叫失敗了，同一時間 Server C 以及我的 local 環境仍然可以正常使用那隻 API。查看 Server B log 後發現顯示的錯誤是：\n1 2 基礎連接已關閉: 傳送時發生未預期錯誤，遠端主機已強制關閉一個現存的連線。 The underlying connection was closed: An unexpected error occurred on a send. 由於是比較古老的服務了，最近一段時間都沒有修改過兩邊的程式碼，所以先排除了改壞了的可能性。把錯誤訊息拿去 google 後，看到通常是因為終止 TLS 1.0、1.1 的服務所導致，只要加上這段程式碼就可以運行了：\n1 ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12; Client Hello \u0026amp; Server Hello 剛好最近重新拾起網路協定的相關書籍閱讀中，書裡有一些使用 Wireshark 的範例，抱持著將就試試看的心態，就打開了 Wireshark 來研究看看到底從我 local 端發送出去的請求和 Server B 到底有甚麼不同。\n從上面這張截圖的比較可以看到，左邊 local 端有出現 Client Hello 和 Server Hello，但右邊 Server B 卻只出現了 Client Hello。但這兩個互相說哈囉的東西是什麼？\nTLS 交握 在網際網路的事件中，應該很多人都聽說過三項交握，全名應該是 TCP 三項交握（TCP Three-Way Handshake），透過這個過程建立連線。\n但是這個連線建立後是沒有加密的狀態，因此要透過 TLS 交握 來確保雙方能安全地交換加密金鑰，並確定加密的協定版本和加密算法。詳細的步驟是：\n客戶端發送 ClientHello 訊息，告知伺服器客戶端這邊支援的 TLS 版本以及密碼套件。 伺服器回應 ServerHello 訊息，選擇使用的加密算法和協定版本，並傳送伺服器證書等資訊來證明身份。 雙方交換加密金鑰和一些安全參數，完成加密通訊的準備。 客戶端和伺服器確認所有訊息交換無誤後，TLS 握手結束，通信開始進入加密的數據傳輸階段。 由於 TLS 的目的就是確保資料在傳輸過程中的機密性、完整性及身份驗證，只要有一個步驟缺失就代表無法建立安全的連線，因此連線就被中斷。從剛剛的截圖可以看到 Server B 確實沒有等到 ServerHello 的訊息，為了確定是不是這個問題，我決定要分別看看這三台 Server 的 TLS 版本以及密碼套件有哪些。\n檢查允許的密碼套件：Qualys Labs Qualys Labs 這個網站主要是針對 SSL 安全性做的掃描，掃描出的內容剛好包含我們所需要的密碼套件清單。操作的方式也很簡單：\n透過這個網站的比對，我確定了這次 Server B 遇到的問題：由於那陣子剛做完弱點掃描，Server A 被掃出了 Weak SSL Protocol 的問題，所以我使用 IIS Crypto 把一些不安全的過時協議關閉，但 Server B 太過古老，沒辦法支援新的協議，這就導致了這次的問題，Server B 只能使用不安全的密碼套件，但 Server A 不允許使用，在沒辦法挑出可用套件的情況下，自然也就沒辦法回覆 ServerHello 的訊息。\n參考資料\nTLS 握手中發生了甚麼事？ 那些關於SSL/TLS的二三事 ","date":"2022-05-03T00:00:00Z","permalink":"https://anthea-wu.github.io/post/%E4%B8%8D%E5%B8%B8%E8%A6%8B%E7%9A%84%E9%81%A0%E7%AB%AF%E4%B8%BB%E6%A9%9F%E5%B7%B2%E5%BC%B7%E5%88%B6%E9%97%9C%E9%96%89%E9%80%A3%E7%B7%9A/","title":"不常見的遠端主機已強制關閉連線"}]