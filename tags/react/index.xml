<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React on Anthea's Blog</title><link>https://anthea-wu.github.io/tags/react/</link><description>Recent content in React on Anthea's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 10 Jun 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://anthea-wu.github.io/tags/react/index.xml" rel="self" type="application/rss+xml"/><item><title>React 初心者大補帖（4）</title><link>https://anthea-wu.github.io/post/react-junior-4/</link><pubDate>Tue, 10 Jun 2025 00:00:00 +0800</pubDate><guid>https://anthea-wu.github.io/post/react-junior-4/</guid><description>&lt;p>在學習 React 的過程中，&lt;code>useEffect&lt;/code> 是許多初學者常常感到困惑的一個 Hook。今天的筆記會記錄一下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>useEffect&lt;/code> 的基本概念&lt;/li>
&lt;li>使用時機&lt;/li>
&lt;li>潛藏陷阱&lt;/li>
&lt;/ul>
&lt;h2 id="-effect-是什麼">🔍 Effect 是什麼？
&lt;/h2>&lt;p>Effect（副作用）是指 &lt;strong>除了 return 值之外還會與外部互動或產生更大影響的行為&lt;/strong>。這些通常包含：&lt;/p>
&lt;ul>
&lt;li>向伺服器發送資料（如 API 請求）&lt;/li>
&lt;li>註冊事件監聽器（如 `window.addEventListener``)&lt;/li>
&lt;li>操作 DOM（例如 &lt;code>document.title = &amp;quot;...&amp;quot;&lt;/code>)&lt;/li>
&lt;li>設定或清除定時器（如 &lt;code>setTimeout&lt;/code>, &lt;code>setInterval&lt;/code>）&lt;/li>
&lt;/ul>
&lt;p>這些副作用行為通常會超出 React 元件本身的範疇，因此 React 提供了 &lt;code>useEffect&lt;/code> 來集中管理這些副作用。&lt;/p>
&lt;h2 id="-effect-可能造成的問題">⚠️ Effect 可能造成的問題
&lt;/h2>&lt;p>如果沒有妥善管理 effect 的執行與清除，可能會出現以下問題：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>記憶體洩漏&lt;/strong>：例如註冊了事件但沒清除&lt;/li>
&lt;li>&lt;strong>多次重複執行&lt;/strong>：依賴沒寫齊，導致每次 render 都重新執行&lt;/li>
&lt;li>&lt;strong>畫面狀態錯亂&lt;/strong>：例如過時的資料仍被使用，造成顯示不一致&lt;/li>
&lt;li>&lt;strong>效能低落&lt;/strong>：頻繁 re-render 導致效能下降&lt;/li>
&lt;/ul>
&lt;h2 id="-useeffect-是什麼">💡 &lt;code>useEffect&lt;/code> 是什麼？
&lt;/h2>&lt;p>&lt;code>useEffect&lt;/code> 是 React 中用來處理副作用的 Hook。它的主要功能有兩個：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>執行副作用程式碼&lt;/strong>：如前述的 API 呼叫、DOM 操作等。&lt;/li>
&lt;li>&lt;strong>清除副作用&lt;/strong>：透過 &lt;code>useEffect&lt;/code> 傳回的清除函式（cleanup function），可以在元件 unmount 或重新執行 effect 前清除先前的副作用，避免記憶體洩漏或非預期行為。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">useEffect&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">timer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">setInterval&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;每秒執行一次&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">clearInterval&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">timer&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 清除副作用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">},&lt;/span> &lt;span class="p">[]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="-useeffect-的用法">🛠️ &lt;code>useEffect&lt;/code> 的用法
&lt;/h2>&lt;p>基本語法如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">useEffect&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 副作用邏輯
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 清除副作用邏輯（可選）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">},&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">dependencies&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="-根據依賴的不同行為會有所差異">📌 根據依賴的不同，行為會有所差異：
&lt;/h3>&lt;ul>
&lt;li>&lt;code>useEffect(someActions)&lt;/code>：沒有指定依賴陣列，每次 render 都會執行，即使狀態沒改變也一樣&lt;/li>
&lt;li>&lt;code>useEffect(someActions, [])&lt;/code>：傳入空陣列作為依賴，在第一次 render 時執行一次，後續 re-render 時會被安全的跳過&lt;/li>
&lt;li>&lt;code>useEffect(someActions, [foo, bar])&lt;/code>：傳入依賴陣列，當 foo 或 bar 的值改變時才會重新執行 effect&lt;/li>
&lt;/ul>
&lt;h2 id="安全的跳過--保證會跳過">❗安全的跳過 ≠ 保證會跳過
&lt;/h2>&lt;p>很多人會誤以為傳入 &lt;code>[]&lt;/code> 就一定不會重新執行，但實際上：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>安全地跳過&lt;/strong>是指跳過沒問題、不跳過也沒問題：有時候依賴沒列齊（例如漏掉某個 context 或 props），會導致效果不如預期&lt;/li>
&lt;li>&lt;strong>dependencies 是效能優化的手段&lt;/strong>，而不是執行時機的主邏輯控制工具&lt;/li>
&lt;/ul>
&lt;p>最好的做法是：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>寫出正確的 effect 邏輯，然後再優化 dependencies。&lt;/strong>&lt;/p>&lt;/blockquote></description></item><item><title>React 初心者大補帖（3）</title><link>https://anthea-wu.github.io/post/react-junior-3/</link><pubDate>Fri, 06 Jun 2025 15:30:00 +0800</pubDate><guid>https://anthea-wu.github.io/post/react-junior-3/</guid><description>&lt;p>在 React 裡，父元件通常 無法直接控制子元件的內部狀態或行為。但有時候，我們希望 父元件可以透過某些方法操作子元件，例如：重置狀態、讀取資料或觸發某些事件——這時候，&lt;code>useImperativeHandle&lt;/code> 就能派上用場。&lt;/p>
&lt;p>這篇文章將透過一個「自動販賣機」的範例，一步步了解：&lt;/p>
&lt;ul>
&lt;li>什麼是 &lt;code>useImperativeHandle&lt;/code>&lt;/li>
&lt;li>它為什麼需要搭配 forwardRef&lt;/li>
&lt;li>如何在實務中運用它來建立一個「可由父元件遙控的子元件」&lt;/li>
&lt;/ul>
&lt;h2 id="-什麼是-useimperativehandle">💡 什麼是 &lt;code>useImperativeHandle&lt;/code>
&lt;/h2>&lt;p>&lt;code>useImperativeHandle&lt;/code> 是一個 React Hook，讓你可以 自訂一個 ref 對應的物件內容。這樣父元件在透過 ref 取得子元件時，不會拿到整個 DOM 或元件實例，而是取得你「想要暴露出去的功能」。&lt;/p>
&lt;p>它通常要和 &lt;code>forwardRef&lt;/code> 一起使用，才能讓函式型元件支援 ref。&lt;/p>
&lt;h2 id="-範例介紹一台自動販賣機">🧪 範例介紹：一台自動販賣機
&lt;/h2>&lt;p>假設我們有一個 VendingMachine 元件，他有自己的內部狀態，包含已選擇的商品、投入的金額等等。但通常來說，我們還會需要一些其他的功能，例如客人發現他選錯飲料了，想要取消購買；或是販賣機異常了，工程師來維修的時候想要重置整個飲料機的狀態，這兩個行為都會牽涉到 VendingMachine 的內部狀態，但因為 這些操作是在父元件中觸發的行為，子元件自己無法預測，也不應該自行處理。&lt;/p>
&lt;p>這樣做有幾個好處：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>保持封裝性&lt;/strong>：子元件仍然控制自己的 state，外部只能透過「指定的介面」來操作它。&lt;/li>
&lt;li>&lt;strong>提供明確 API&lt;/strong>：讓元件的使用者知道有哪些功能可以用，不會亂操作。&lt;/li>
&lt;li>&lt;strong>應付複雜交互邏輯&lt;/strong>：像是「取消交易」、「重置系統」這類跨元件操作就能被妥善處理。&lt;/li>
&lt;/ul>
&lt;p>因此，在我們的自動販賣機範例中，我們選擇將以下三個功能透過 &lt;code>useImperativeHandle&lt;/code> 提供給外部元件使用：&lt;/p>
&lt;ul>
&lt;li>&lt;code>cancelSelection&lt;/code>: 客人取消交易&lt;/li>
&lt;li>&lt;code>resetMachine&lt;/code>: 工程師重置機器&lt;/li>
&lt;li>&lt;code>getCurrentStatus&lt;/code>: 查詢目前販賣機的狀態&lt;/li>
&lt;/ul>
&lt;p>下一步就讓我們來看要怎麼使用 &lt;code>useImperativeHandle&lt;/code> 吧。&lt;/p>
&lt;h2 id="-建立可控制的子元件vendingmachine">👷 建立可控制的子元件：VendingMachine
&lt;/h2>&lt;h3 id="第一步使用-forwardref-包裝元件">第一步：使用 &lt;code>forwardRef&lt;/code> 包裝元件
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">VendingMachine&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">forwardRef&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">VendingMachineRef&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">VendingMachineProps&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// component
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="第二步定義要暴露給外部的功能">第二步：定義要暴露給外部的功能
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">useImperativeHandle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ref&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">cancelSelection&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 清除狀態並通知取消
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">resetMachine&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 將狀態重置為初始狀態
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">getCurrentStatus&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 回傳目前的狀態描述字串
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}),&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">selectedItem&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">insertedMoney&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">status&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">onCancel&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="-父元件透過-ref-呼叫子元件方法">👨‍🔧 父元件：透過 ref 呼叫子元件方法
&lt;/h2>&lt;h3 id="第三步使用-useref-建立-ref">第三步：使用 &lt;code>useRef&lt;/code> 建立 ref
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">vendingMachineRef&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useRef&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">VendingMachineRef&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="第四步在父元件中呼叫子元件方法">第四步：在父元件中呼叫子元件方法
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">customerCancel&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">vendingMachineRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">cancelSelection&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">technicianReset&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">vendingMachineRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">resetMachine&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">checkStatus&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">vendingMachineRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getCurrentStatus&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">setMachineStatus&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">status&lt;/span> &lt;span class="o">??&lt;/span> &lt;span class="s2">&amp;#34;無法獲取狀態&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="-useimperativehandle-的應用情境">✅ &lt;code>useImperativeHandle&lt;/code> 的應用情境
&lt;/h2>&lt;p>這種做法特別適合用在：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>表單控制&lt;/strong>：例如讓父元件觸發表單驗證、重置欄位&lt;/li>
&lt;li>&lt;strong>外部控制元件&lt;/strong>：像 modal、canvas、圖表、音樂播放器等需要控制的 UI&lt;/li>
&lt;li>&lt;strong>設計可複用元件 API&lt;/strong>：把內部邏輯包在元件中，只暴露必要的 API 給使用者&lt;/li>
&lt;/ul>
&lt;p>不過要注意的是，&lt;code>useImperativeHandle&lt;/code> 不會讓你繞過 React 的「單向資料流」原則，因為你只能操作子元件「允許」的部分。&lt;/p>
&lt;p>若父元件可以直接控制全部狀態，那就不需要這個 hook，只有在子元件內部邏輯複雜、但又需要提供部分控制給外部時才用得到。&lt;/p>
&lt;h2 id="-結語">📎 結語
&lt;/h2>&lt;p>&lt;code>useImperativeHandle&lt;/code> 在實務中雖然使用頻率不高，但在處理一些進階的互動場景（例如這個自動販賣機）時，可以幫你建立乾淨又可控制的元件 API，讓元件設計更彈性、更模組化。&lt;/p>
&lt;p>希望你喜歡今天的文章，我們下次再見 👋🏻&lt;/p></description></item><item><title>React 初心者大補帖（2）</title><link>https://anthea-wu.github.io/post/react-juniors-2/</link><pubDate>Thu, 29 May 2025 16:00:00 +0800</pubDate><guid>https://anthea-wu.github.io/post/react-juniors-2/</guid><description>&lt;p>最近在幫一個有使用到 react-query 的元件寫測試時遇到一個狀況：&lt;/p>
&lt;p>&lt;img src="https://anthea-wu.github.io/post/react-juniors-2/react-1.png"
width="1400"
height="1449"
srcset="https://anthea-wu.github.io/post/react-juniors-2/react-1_hu_b14a05e355e7b0c9.png 480w, https://anthea-wu.github.io/post/react-juniors-2/react-1_hu_33760f67a8bd424b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="96"
data-flex-basis="231px"
>&lt;/p>
&lt;p>可以看到在上面的程式碼中，我有針對 error 做一些處理，因此我想寫個測試確認當我的 API 回傳錯誤後有正確的被處理：&lt;/p>
&lt;p>&lt;img src="https://anthea-wu.github.io/post/react-juniors-2/react-2.png"
width="1400"
height="1491"
srcset="https://anthea-wu.github.io/post/react-juniors-2/react-2_hu_71aa5c78a10743ec.png 480w, https://anthea-wu.github.io/post/react-juniors-2/react-2_hu_4031da0e6086326b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="225px"
>&lt;/p>
&lt;p>但當我這執行測試後，卻發現測試執行不過：&lt;/p>
&lt;p>&lt;img src="https://anthea-wu.github.io/post/react-juniors-2/react-3.png"
width="1166"
height="750"
srcset="https://anthea-wu.github.io/post/react-juniors-2/react-3_hu_504b9639f1ad70e9.png 480w, https://anthea-wu.github.io/post/react-juniors-2/react-3_hu_7aaea932c0aba0f1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="373px"
>&lt;/p>
&lt;p>可以從 console 中看到，錯誤是在驗證錯誤處理就被拋出了，在這裡下了 console log 之後可以看到目前的 result &lt;code>isLoading = true&lt;/code> ：&lt;/p>
&lt;p>&lt;img src="https://anthea-wu.github.io/post/react-juniors-2/react-4.png"
width="1400"
height="2081"
srcset="https://anthea-wu.github.io/post/react-juniors-2/react-4_hu_528895f53bc200c7.png 480w, https://anthea-wu.github.io/post/react-juniors-2/react-4_hu_93f681ac9fac975.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="67"
data-flex-basis="161px"
>&lt;/p>
&lt;h2 id="為什麼會這樣">為什麼會這樣？
&lt;/h2>&lt;p>根據 &lt;a class="link" href="https://tanstack.com/query/latest/docs/framework/react/guides/query-retries" target="_blank" rel="noopener"
>TanStack Query 官方文件&lt;/a> 的說明，react-query 預設會對失敗的請求重試三次，並使用指數退避（exponential backoff）策略，初始延遲為 1 秒，每次加倍，最多延遲 30 秒。&lt;/p>
&lt;p>這就是為什麼我們的測試會噴掉的原因：&lt;/p>
&lt;p>&lt;img src="https://anthea-wu.github.io/post/react-juniors-2/react-5.png"
width="1400"
height="1006"
srcset="https://anthea-wu.github.io/post/react-juniors-2/react-5_hu_566a512020fd2fb1.png 480w, https://anthea-wu.github.io/post/react-juniors-2/react-5_hu_56274ad38b882fe6.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="139"
data-flex-basis="333px"
>&lt;/p>
&lt;h2 id="怎麼修正">怎麼修正？
&lt;/h2>&lt;p>為了避免在測試中出現非預期的重試行為，可以在建立 QueryClient 時設定：&lt;/p>
&lt;p>&lt;img src="https://anthea-wu.github.io/post/react-juniors-2/react-6.png"
width="1400"
height="866"
srcset="https://anthea-wu.github.io/post/react-juniors-2/react-6_hu_92d53e5463f1cfe1.png 480w, https://anthea-wu.github.io/post/react-juniors-2/react-6_hu_fb8c73782d85928a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="387px"
>&lt;/p>
&lt;p>這樣除非在個別查詢中另行設定，不然預設就是禁用全域重試囉。&lt;/p></description></item><item><title>React 初心者大補帖（1）</title><link>https://anthea-wu.github.io/post/react-junior-1/</link><pubDate>Fri, 23 May 2025 16:00:00 +0800</pubDate><guid>https://anthea-wu.github.io/post/react-junior-1/</guid><description>&lt;p>在開發 React Component 或 Hook 時，常會看到像這樣的程式碼：&lt;/p>
&lt;p>&lt;img src="https://anthea-wu.github.io/post/react-junior-1/react-1.png"
width="1400"
height="945"
srcset="https://anthea-wu.github.io/post/react-junior-1/react-1_hu_6b359d5bc58ca69a.png 480w, https://anthea-wu.github.io/post/react-junior-1/react-1_hu_4a75a3c6a48d7690.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="148"
data-flex-basis="355px"
>&lt;/p>
&lt;p>這看起來像是違反了 JavaScript 的規則，因為你在宣告 someStrategy 之前就用了它，但實際上這是合法的行為，也是 JavaScript 的預期表現。&lt;/p>
&lt;p>一般來說，我們會在學習 JavaScript 的過程中看到這件事情：在 JavaScript 中，使用 const 或 let 宣告的變數不能在宣告之前被使用，否則會拋出 ReferenceError，這段期間稱為 TDZ（Temporal Dead Zone，暫時性死區）。&lt;/p>
&lt;p>也就是說，如果你在變數「初始化之前」就嘗試使用它，JS 會拒絕執行：&lt;/p>
&lt;p>&lt;img src="https://anthea-wu.github.io/post/react-junior-1/react-2.png"
width="1400"
height="255"
srcset="https://anthea-wu.github.io/post/react-junior-1/react-2_hu_31e457ab09524d7f.png 480w, https://anthea-wu.github.io/post/react-junior-1/react-2_hu_2f52b61fd00fcada.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="549"
data-flex-basis="1317px"
>&lt;/p>
&lt;p>所以我們直覺上會認為：&lt;/p>
&lt;blockquote>
&lt;p>變數宣告在下面，上面就不該能用了吧？&lt;/p>&lt;/blockquote>
&lt;p>但實際上，在 React 函式（或 Hook）中這種結構是合法的，讓我們一起看下去吧。&lt;/p>
&lt;h2 id="react-並沒有魔法">React 並沒有魔法
&lt;/h2>&lt;p>看起來在 React 中很神奇的事情，其實背後還是離不開 JavaScript 原本的行為。讓我們先來看看兩件事情的運作：Hoisting &amp;amp; 函式延遲執行（Deferred Execution）。&lt;/p>
&lt;h3 id="1-模組層級的-hoisting提升">1. 模組層級的 Hoisting（提升）
&lt;/h3>&lt;p>在 ES Module 中，所有頂層的變數（const、let、var）、函式（function）在解析階段都會被「提升（hoist）」，意思是：JavaScript 會先掃描整個模組，把變數名稱、函式簽名都「先登記起來」。&lt;/p>
&lt;p>不過 const/let 會處在 Temporal Dead Zone（暫時性死區，TDZ） 中，直到程式執行到那行才初始化。因此：&lt;/p>
&lt;p>&lt;img src="https://anthea-wu.github.io/post/react-junior-1/react-3.png"
width="1400"
height="419"
srcset="https://anthea-wu.github.io/post/react-junior-1/react-3_hu_295000377c022f86.png 480w, https://anthea-wu.github.io/post/react-junior-1/react-3_hu_9eada2c27593b852.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="334"
data-flex-basis="801px"
>&lt;/p>
&lt;h3 id="2-函式是延遲執行deferred-execution">2. 函式是延遲執行（Deferred Execution）
&lt;/h3>&lt;p>在 JavaScript 中，函式的「定義」和「執行」是兩回事。&lt;/p>
&lt;p>當 JS 解讀一段程式時，它會先記住你定義了哪些函式，但不會馬上執行它們，直到你主動「呼叫」它們為止。&lt;/p>
&lt;p>舉個例子：&lt;/p>
&lt;p>&lt;img src="https://anthea-wu.github.io/post/react-junior-1/react-4.png"
width="1400"
height="703"
srcset="https://anthea-wu.github.io/post/react-junior-1/react-4_hu_c462b53b8410ec59.png 480w, https://anthea-wu.github.io/post/react-junior-1/react-4_hu_51208dfcf57bf221.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="199"
data-flex-basis="477px"
>&lt;/p>
&lt;p>在 React 裡也是一樣，useHello 是一個函式，它的內容直到被呼叫時才會執行。因此即使 strategy 使用了尚未「寫到」的 helloStrategy，只要函式呼叫的時候 helloStrategy 已經初始化完，就不會有問題。&lt;/p>
&lt;p>綜合以上兩點，我們可以理解到 React 並沒有魔法，在 const 定義前先呼叫並使用 const 的值是 JavaScript 裡正常的行為，只是因為 模組先執行、函式後呼叫 所帶來的結果。&lt;/p></description></item></channel></rss>